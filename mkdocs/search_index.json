{
    "docs": [
        {
            "location": "/", 
            "text": "Projects and Notes\n\n\nBelow are a list of notes and projects I have been working on. I use this page mainly \nfor my own reference but other people might find something useful.\n\n\nCloud Computing\n\n\n\n\n'Terraform: Up \n Running' code samples translated\n\n\n\n\nSoftware Development\n\n\n\n\nMy collection of IPython notebooks\n\n\nTesting Python Code with Hypothesis\n\n\n\n\nNetworking\n\n\n\n\nInstalling GNS3 on CentOS 7\n\n\nBasic IPv6 on Cisco IOS\n\n\n\n\nLinks\n\n\nMy other presence on the Internet.\n\n\n\n\nGithub\n\n\nLinkedIn\n\n\nTravis-CI", 
            "title": "Home"
        }, 
        {
            "location": "/#projects-and-notes", 
            "text": "Below are a list of notes and projects I have been working on. I use this page mainly \nfor my own reference but other people might find something useful.", 
            "title": "Projects and Notes"
        }, 
        {
            "location": "/#cloud-computing", 
            "text": "'Terraform: Up   Running' code samples translated", 
            "title": "Cloud Computing"
        }, 
        {
            "location": "/#software-development", 
            "text": "My collection of IPython notebooks  Testing Python Code with Hypothesis", 
            "title": "Software Development"
        }, 
        {
            "location": "/#networking", 
            "text": "Installing GNS3 on CentOS 7  Basic IPv6 on Cisco IOS", 
            "title": "Networking"
        }, 
        {
            "location": "/#links", 
            "text": "My other presence on the Internet.   Github  LinkedIn  Travis-CI", 
            "title": "Links"
        }, 
        {
            "location": "/installing_gns3_on_centos7/", 
            "text": "Installing GNS3 on CentOS 7\n\n\nGNS3 is a popular network software emulator. It uses the Dynamips emulation software\nto simulate Cisco IOS. The official documentation includes installation guides for\nUbuntu, Debian, Arch Linux, Fedora and OpenSuse. This article explains how to install\nGNS3 on CentOS 7.\n\n\nRequirements\n\n\nGNS3 is written in Python 3, Python 2 is not supported. The Python 3 packages are not\navailable through the CentOS RPM repositories but they are available on EPEL.\nThe steps below add the EPEL repository, install Python 3.4, QT5 and various other\npackages that are either needed or are useful for running GNS3.\n\n\nsudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\nsudo yum install python34 python34-devel python34-setuptools python34-tools\nsudo yum install elfutils-libelf-devel libpcap-devel cmake glibc-static qemu telnet gnome-terminal putty\nsudo yum install qt5-qtbase qt5-qtbase-devel qt5-qtsvg qt5-qtsvg-devel\nsudo yum groupinstall Fonts\ncurl https://bootstrap.pypa.io/get-pip.py | sudo python3.4\n\n\n\n\nGNS3\n\n\nOnce Python 3.4 has been installed, the latest GNS3 releases are available from PyPi \nand are easily installed through the pip3.4 script.\n\n\nsudo pip3.4 install gns3-server gns3-gui\n\n\n\n\nQt5 and Python 3 bindings\n\n\nGNS3 relies on the Python 3 bindings for the QT5 toolkit. These are not available for\nCentOS 7 from any repository and must be installed from source code. This section is\nheavily based on the instructions found at \n\nhttp://robertbasic.com/blog/install-pyqt5-in-python-3-virtual-environment/\n.\n\n\nSIP\n\n\ncd /tmp\nwget http://sourceforge.net/projects/pyqt/files/sip/sip-4.16.5/sip-4.16.5.tar.gz\ntar xvfz sip-4.16.5.tar.gz\ncd sip-4.16.5\npython3.4 configure.py\nmake\nsudo make install\n\n\n\n\n\nPyQt5\n\n\nBuilding PyQt5 from source will take a while.\n\n\ncd /tmp\nwget http://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4/PyQt-gpl-5.4.tar.gz\ntar xzf PyQt-gpl-5.4.tar.gz\ncd PyQt-gpl-5.4\npython3.4 configure.py --qmake /usr/bin/qmake-qt5\nmake\nsudo make install\n\n\n\n\n\nDynamips\n\n\nDynamips is a Cisco router emulator. It started as a separate project in 2005 but the\nsources are now part of the GNS3 repositories on Github.\n\n\ncd /tmp\ngit clone https://github.com/GNS3/dynamips.git\ncd dynamips/\nmkdir build\ncd build/\ncmake .. -DDYNAMIPS_CODE=stable\nmake\nsudo make install\n\n\n\n\n\nVPCS\n\n\nThe Virtual PC Simulator (VPCS) can be used in GNS3 to add simple PCs to a network\ntopology. The steps below will install the /usr/local/bin/vpcs from source code.\n\n\ncd /tmp\nsvn checkout http://svn.code.sf.net/p/vpcs/code/trunk vpcs\ncd vpcs/src\n./mk.sh 64\nsudo install -m 755 vpcs /usr/local/bin\n\n\n\n\n\nThat's all.", 
            "title": "Installing GNS3 on CentOS 7"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#installing-gns3-on-centos-7", 
            "text": "GNS3 is a popular network software emulator. It uses the Dynamips emulation software\nto simulate Cisco IOS. The official documentation includes installation guides for\nUbuntu, Debian, Arch Linux, Fedora and OpenSuse. This article explains how to install\nGNS3 on CentOS 7.", 
            "title": "Installing GNS3 on CentOS 7"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#requirements", 
            "text": "GNS3 is written in Python 3, Python 2 is not supported. The Python 3 packages are not\navailable through the CentOS RPM repositories but they are available on EPEL.\nThe steps below add the EPEL repository, install Python 3.4, QT5 and various other\npackages that are either needed or are useful for running GNS3.  sudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\nsudo yum install python34 python34-devel python34-setuptools python34-tools\nsudo yum install elfutils-libelf-devel libpcap-devel cmake glibc-static qemu telnet gnome-terminal putty\nsudo yum install qt5-qtbase qt5-qtbase-devel qt5-qtsvg qt5-qtsvg-devel\nsudo yum groupinstall Fonts\ncurl https://bootstrap.pypa.io/get-pip.py | sudo python3.4", 
            "title": "Requirements"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#gns3", 
            "text": "Once Python 3.4 has been installed, the latest GNS3 releases are available from PyPi \nand are easily installed through the pip3.4 script.  sudo pip3.4 install gns3-server gns3-gui", 
            "title": "GNS3"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#qt5-and-python-3-bindings", 
            "text": "GNS3 relies on the Python 3 bindings for the QT5 toolkit. These are not available for\nCentOS 7 from any repository and must be installed from source code. This section is\nheavily based on the instructions found at  http://robertbasic.com/blog/install-pyqt5-in-python-3-virtual-environment/ .", 
            "title": "Qt5 and Python 3 bindings"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#sip", 
            "text": "cd /tmp\nwget http://sourceforge.net/projects/pyqt/files/sip/sip-4.16.5/sip-4.16.5.tar.gz\ntar xvfz sip-4.16.5.tar.gz\ncd sip-4.16.5\npython3.4 configure.py\nmake\nsudo make install", 
            "title": "SIP"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#pyqt5", 
            "text": "Building PyQt5 from source will take a while.  cd /tmp\nwget http://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4/PyQt-gpl-5.4.tar.gz\ntar xzf PyQt-gpl-5.4.tar.gz\ncd PyQt-gpl-5.4\npython3.4 configure.py --qmake /usr/bin/qmake-qt5\nmake\nsudo make install", 
            "title": "PyQt5"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#dynamips", 
            "text": "Dynamips is a Cisco router emulator. It started as a separate project in 2005 but the\nsources are now part of the GNS3 repositories on Github.  cd /tmp\ngit clone https://github.com/GNS3/dynamips.git\ncd dynamips/\nmkdir build\ncd build/\ncmake .. -DDYNAMIPS_CODE=stable\nmake\nsudo make install", 
            "title": "Dynamips"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#vpcs", 
            "text": "The Virtual PC Simulator (VPCS) can be used in GNS3 to add simple PCs to a network\ntopology. The steps below will install the /usr/local/bin/vpcs from source code.  cd /tmp\nsvn checkout http://svn.code.sf.net/p/vpcs/code/trunk vpcs\ncd vpcs/src\n./mk.sh 64\nsudo install -m 755 vpcs /usr/local/bin  That's all.", 
            "title": "VPCS"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/", 
            "text": "Basic IPv6 on Cisco IOS\n\n\nGlobal settings\n\n\nThere are a couple of global settings that enable IPv6 on a Cisco router. The example below also shows two host name to IPv6 address mappings.\n\n\nip routing\nipv6 unicast-routing\n\nip cef\nipv6 cef\n\nipv6 host R1 FDFC:38C4:F0BE:FFFF::1\nipv6 host R2 FDFC:38C4:F0BE:FFFF::2\n\n\n\n\nInterfaces\n\n\nThe example below shows a dual-stack configuration for an Ethernet interface. \n\nFDFC:38C4:F0BE/48\n is the unique-local address (ULA) prefix registered with \nthe \nIPv6 ULA (Unique Local Address) RFC4193 Registration List\n.\nThe IPv6 subnet on this interface is \n...:1::...\n and the host address is \n...::1\n.\n\n\n# sh run int e1/0\ninterface Ethernet1/0\n ip address 192.168.1.1 255.255.255.0\n ipv6 address FDFC:38C4:F0BE:1::1/64\n ipv6 enable\n\n\n\n\nThe loopback interface is on IPv6 subnet \nFFFF\n. Like its IPv4 address, \nits IPv6 address has a netmask with all bits set (/128).\n\n\n# sh run int lo0\ninterface Loopback0\n ip address 192.168.255.1 255.255.255.255\n ipv6 address FDFC:38C4:F0BE:FFFF::1/128\n ipv6 enable\n\n\n\n\nThe show ipv6 interface command displays IPv6 information for that interface\n\n\n# sh ipv6 interface e1/0\nEthernet1/0 is up, line protocol is up\n  IPv6 is enabled, link-local address is FE80::C801:32FF:FE70:1C\n  Global unicast address(es):\n    FDFC:38C4:F0BE:1::1, subnet is FDFC:38C4:F0BE:1::/64\n  Joined group address(es):\n    FF02::1\n    FF02::2\n    FF02::1:FF00:1\n    FF02::1:FF70:1C\n  MTU is 1500 bytes\n  ICMP error messages limited to one every 100 milliseconds\n  ICMP redirects are enabled\n  ND DAD is enabled, number of DAD attempts: 1\n  ND reachable time is 30000 milliseconds\n  ND advertised reachable time is 0 milliseconds\n  ND advertised retransmit interval is 0 milliseconds\n  ND router advertisements are sent every 200 seconds\n  ND router advertisements live for 1800 seconds\n  Hosts use stateless autoconfig for addresses.\n192.168.1.1/24 (IPv4)\nFDFC:38C4:F0BE:1::1/64 (IPv6 unique-local address; ULA)\nFE80::... (IPv6 link local)\nff02::1 (All nodes on the local network segment)\nFF02::2 (All routers on the local network segment)\nFF02::1:FF00:1 (Solicited-node multicast address; used for Neighbour-Disovery)\nFF02::1:FF70:1C (???)\n\n\n\n\nShow IPv6 ...\n\n\nNeighbor Cache\n\n\n# sh ipv6 neighbors [e1/0]\nIPv6 Address                              Age Link-layer Addr State Interface\nFE80::C802:32FF:FE7F:1C                     0 ca02.327f.001c  REACH Et1/0\nFDFC:38C4:F0BE:1::2                         0 ca02.327f.001c  STALE Et1/0\n\n\n\n\nRoutes\n\n\n# sh ipv6 route\nIPv6 Routing Table - 6 entries\nCodes: C - Connected, L - Local, S - Static, R - RIP, B - BGP\n       U - Per-user Static route\n       I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea, IS - ISIS summary\n       O - OSPF intra, OI - OSPF inter, OE1 - OSPF ext 1, OE2 - OSPF ext 2\n       ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2\nC   FDFC:38C4:F0BE:1::/64 [0/0]\n     via ::, Ethernet1/0\nL   FDFC:38C4:F0BE:1::1/128 [0/0]\n     via ::, Ethernet1/0\nC   FDFC:38C4:F0BE:4::/64 [0/0]\n     via ::, Ethernet1/1\nL   FDFC:38C4:F0BE:4::1/128 [0/0]\n     via ::, Ethernet1/1\nL   FE80::/10 [0/0]\n     via ::, Null0\nL   FF00::/8 [0/0]\n     via ::, Null0\n\n\n\n\nOSPFv3\n\n\nOSPFv3 expands on OSPF version 2 to provide support for IPv6 routing prefixes and\nthe larger size of IPv6 addresses. In regards to configuring OSPFv3 on Cisco IOS there\nare two key differences to OSPFv2.\n\n\n\n\nIn OSPFv3, a routing process does not need to be explicitly created. Enabling OSPFv3\n  on an interface will cause a routing process, and its associated configuration,\n  to be created. One may still want to customise OSPFv3 parameters that are not\n  interface specific.\n\n\nIn OSPFv3, each interface must be enabled using commands in interface configuration\n  mode. This feature is different from OSPF version 2, in which interfaces are\n  indirectly enabled using the device configuration mode.\n\n\n\n\nOSPFv3 can be used for IPv6 and IPv4 as long as separate OSPF processes are used.\nYou may want to use OSPFv2 for IPv4 and OSPFv3 only for IPv6. The example below\nconfigures a single OSPFv3 zone for IPv6 only.\n\n\nEnabling OSPFv3 authentication is so simple that there is no reason for not doing so.\n\n\n# sh run\ninterface Ethernet1/0\n  ...\n  ipv6 ospf 1 area 0\n\nipv6 router ospf 1\n log-adjacency-changes\n redistribute connected\n area 0 authentication ipsec spi 1000 md5 8B800BD784E62C8C8B0A8DEA3451A25E", 
            "title": "Basic IPv6 on Cisco IOS"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#basic-ipv6-on-cisco-ios", 
            "text": "", 
            "title": "Basic IPv6 on Cisco IOS"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#global-settings", 
            "text": "There are a couple of global settings that enable IPv6 on a Cisco router. The example below also shows two host name to IPv6 address mappings.  ip routing\nipv6 unicast-routing\n\nip cef\nipv6 cef\n\nipv6 host R1 FDFC:38C4:F0BE:FFFF::1\nipv6 host R2 FDFC:38C4:F0BE:FFFF::2", 
            "title": "Global settings"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#interfaces", 
            "text": "The example below shows a dual-stack configuration for an Ethernet interface.  FDFC:38C4:F0BE/48  is the unique-local address (ULA) prefix registered with \nthe  IPv6 ULA (Unique Local Address) RFC4193 Registration List .\nThe IPv6 subnet on this interface is  ...:1::...  and the host address is  ...::1 .  # sh run int e1/0\ninterface Ethernet1/0\n ip address 192.168.1.1 255.255.255.0\n ipv6 address FDFC:38C4:F0BE:1::1/64\n ipv6 enable  The loopback interface is on IPv6 subnet  FFFF . Like its IPv4 address, \nits IPv6 address has a netmask with all bits set (/128).  # sh run int lo0\ninterface Loopback0\n ip address 192.168.255.1 255.255.255.255\n ipv6 address FDFC:38C4:F0BE:FFFF::1/128\n ipv6 enable  The show ipv6 interface command displays IPv6 information for that interface  # sh ipv6 interface e1/0\nEthernet1/0 is up, line protocol is up\n  IPv6 is enabled, link-local address is FE80::C801:32FF:FE70:1C\n  Global unicast address(es):\n    FDFC:38C4:F0BE:1::1, subnet is FDFC:38C4:F0BE:1::/64\n  Joined group address(es):\n    FF02::1\n    FF02::2\n    FF02::1:FF00:1\n    FF02::1:FF70:1C\n  MTU is 1500 bytes\n  ICMP error messages limited to one every 100 milliseconds\n  ICMP redirects are enabled\n  ND DAD is enabled, number of DAD attempts: 1\n  ND reachable time is 30000 milliseconds\n  ND advertised reachable time is 0 milliseconds\n  ND advertised retransmit interval is 0 milliseconds\n  ND router advertisements are sent every 200 seconds\n  ND router advertisements live for 1800 seconds\n  Hosts use stateless autoconfig for addresses.\n192.168.1.1/24 (IPv4)\nFDFC:38C4:F0BE:1::1/64 (IPv6 unique-local address; ULA)\nFE80::... (IPv6 link local)\nff02::1 (All nodes on the local network segment)\nFF02::2 (All routers on the local network segment)\nFF02::1:FF00:1 (Solicited-node multicast address; used for Neighbour-Disovery)\nFF02::1:FF70:1C (???)", 
            "title": "Interfaces"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#show-ipv6", 
            "text": "", 
            "title": "Show IPv6 ..."
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#neighbor-cache", 
            "text": "# sh ipv6 neighbors [e1/0]\nIPv6 Address                              Age Link-layer Addr State Interface\nFE80::C802:32FF:FE7F:1C                     0 ca02.327f.001c  REACH Et1/0\nFDFC:38C4:F0BE:1::2                         0 ca02.327f.001c  STALE Et1/0", 
            "title": "Neighbor Cache"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#routes", 
            "text": "# sh ipv6 route\nIPv6 Routing Table - 6 entries\nCodes: C - Connected, L - Local, S - Static, R - RIP, B - BGP\n       U - Per-user Static route\n       I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea, IS - ISIS summary\n       O - OSPF intra, OI - OSPF inter, OE1 - OSPF ext 1, OE2 - OSPF ext 2\n       ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2\nC   FDFC:38C4:F0BE:1::/64 [0/0]\n     via ::, Ethernet1/0\nL   FDFC:38C4:F0BE:1::1/128 [0/0]\n     via ::, Ethernet1/0\nC   FDFC:38C4:F0BE:4::/64 [0/0]\n     via ::, Ethernet1/1\nL   FDFC:38C4:F0BE:4::1/128 [0/0]\n     via ::, Ethernet1/1\nL   FE80::/10 [0/0]\n     via ::, Null0\nL   FF00::/8 [0/0]\n     via ::, Null0", 
            "title": "Routes"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#ospfv3", 
            "text": "OSPFv3 expands on OSPF version 2 to provide support for IPv6 routing prefixes and\nthe larger size of IPv6 addresses. In regards to configuring OSPFv3 on Cisco IOS there\nare two key differences to OSPFv2.   In OSPFv3, a routing process does not need to be explicitly created. Enabling OSPFv3\n  on an interface will cause a routing process, and its associated configuration,\n  to be created. One may still want to customise OSPFv3 parameters that are not\n  interface specific.  In OSPFv3, each interface must be enabled using commands in interface configuration\n  mode. This feature is different from OSPF version 2, in which interfaces are\n  indirectly enabled using the device configuration mode.   OSPFv3 can be used for IPv6 and IPv4 as long as separate OSPF processes are used.\nYou may want to use OSPFv2 for IPv4 and OSPFv3 only for IPv6. The example below\nconfigures a single OSPFv3 zone for IPv6 only.  Enabling OSPFv3 authentication is so simple that there is no reason for not doing so.  # sh run\ninterface Ethernet1/0\n  ...\n  ipv6 ospf 1 area 0\n\nipv6 router ospf 1\n log-adjacency-changes\n redistribute connected\n area 0 authentication ipsec spi 1000 md5 8B800BD784E62C8C8B0A8DEA3451A25E", 
            "title": "OSPFv3"
        }, 
        {
            "location": "/testing_python_code_with_hypothesis/", 
            "text": "Testing Python code with Hypothesis\n\n\nAccording to its \nweb page\n \"Hypothesis is a new generation\nof tools for automating your\ntesting process. It combines human understanding of your problem domain with machine\nintelligence to improve the quality of your testing process while spendingless time\nwriting tests.\" That sounds all nice and fancy but what does this in mean in practice?\nThis article provides a quick introduction to Hypothesis, just to whet your appetite.\nThe \nofficial documentation\n\nprovides a more extensive tutorial.\n\n\nHypothesis is available on PyPi and can be easily installed through pip. Hypothesis\nworks in conjunction with a Python test suite. My personal preference is \n\nNose\n but\nothers are supported, too.\n\n\n$ pip install hypothesis nose\nCollecting hypothesis\nCollecting nose\n  Using cached nose-1.3.7-py2-none-any.whl\nCollecting enum34 (from hypothesis)\n  Using cached enum34-1.1.6-py2-none-any.whl\nInstalling collected packages: enum34, hypothesis, nose\nSuccessfully installed enum34-1.1.6 hypothesis-3.6.1 nose-1.3.7\n\n\n\n\nFor the purpose of this article I am going to explain how Hypothesis works with a\nsimple custom \ndivision()\n function that accepts numbers or strings containing numbers.\nI admit that this example is rather contrived but it serves the purpose of this article\nreally well. The first listing implements the test functions with some assistance\nof Nose.\n\n\n# example1.py\nfrom nose.tools import raises\n\ndef division(x, y):\n    return float(x) / float(y)\n\ndef test_div():\n    \nTest numbers and strings.\n\n    assert division(4, 2.0) == division('4', '2.0')\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n    \nTest division by zero.\n\n    division('4', 0)\n\n\n\n\nWhat is immediately obvious is that only a very limited set of possible arguments to\n\ndivision()\n is tested. Most people can immediately think of additional combinations of\nintegers, floats and string representations worth testing.\n\n\n$ nosetests example1.py \n..\n----------------------------------------------------------------------\nRan 2 tests in 0.000s\n\nOK\n\n\n\n\nThe second example adds tests for numbers from 1 to 10, also as floats and strings.\n\n\n# example2.py\n\nfrom nose.tools import raises\n\ndef division(x, y):\n    return float(x) / float(y)\n\ndef check_division(x, y):\n    assert division(x, y) == 2.0\n\ndef test_div():\n    \nTest numbers and strings.\n\n    for i in range(1, 10):\n        yield division, i*2, i\n        yield division, float(i*2), i\n        yield division, i*2, float(i)\n        yield division, float(i*2), float(i)\n        yield division, i*2, str(i)\n        yield division, str(i*2), i\n        # and so forth...\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n    \nTest division by zero.\n\ufeff\ufeff\n    division('4', 0)\n\n\n\n\nIt covers many more combinations, but is still limited to a tiny subset of possible\nnumbers. It also doesn't look very elegant?\n\n\n$ nosetests example2.py \n.......................................................\n----------------------------------------------------------------------\nRan 55 tests in 0.005s\nOK\n\n\n\n\nLike the first example it provides a specific test case for the ZeroDivisionError\nexception. But are there any other special cases? Maybe Hypothesis can find one.\n\n\nThe key objective of Hypothesis is to generate input data for test functions. And\nit does so very cleverly. Let's rewrite the test and use Hypothesis. Through\nthe \n@given\n decorator Hypothesis will create a series of integers to the test.\n\n\n# example3.py\n\nfrom nose.tools import raises\nfrom hypothesis import given\nfrom hypothesis.strategies import integers\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(x=integers())\ndef test_div(x):\n    \nTest integers.\n\n    print x               # show value of x, normally not done!\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n    \nTest division by zero.\n\ufeff\ufeff\n    division('4', 0)\n\n\n\n\nUnfortunately the \n@given(x=integers())\n line introduces the ZeroDivisionError into\nthe test. This was bound to happen as 0 is a valid integer. Note that the output\nclearly shows what input caused the test to fail (\nFalsifying example: ...\n) and\nbecause of the print statement in the code it also shows the different other integer\nvalues Hypothesis tried.\n\n\n$ nosetests example3.py \nE.\n======================================================================\nERROR: example3.test_div\n----------------------------------------------------------------------\nTraceback (most recent call last):\n[...]\nZeroDivisionError: float division by zero\n-------------------- \n begin captured stdout \n ---------------------\n-86\n38698778983165550746815151433416776989\n130775184150007723213375339326718763618\n-149\n-60717049783932157206209978973119425965\n0\n0\n0\nFalsifying example: test_div(x=0)\n0\n--------------------- \n end captured stdout \n ----------------------\n----------------------------------------------------------------------\nRan 2 tests in 0.011s\nFAILED (errors=1)\n\n\n\n\nQuite clearly we have to amend the code to prevent Hypothesis causing the\nZeroDivisionError exception. The assume function serves this purpose.\n\n\n# example4.py\n\nfrom nose.tools import raises\nfrom hypothesis import given, assume\nfrom hypothesis.strategies import integers\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(x=integers())\ndef test_div(x):\n    \nTest non-zero integers.\n\n    assume(x \n 0)                      # \n-----------\n\n    print x    # show value of x, normally not done!\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n    \nTest division by zero.\n\n    division('4', 0)\nNow the tests pass.\n\n$ nosetests example4.py \n..\n----------------------------------------------------------------------\nRan 2 tests in 0.045s\nOK\n\n\n\n\nBut what about other numbers than integers? The next example adds floats to the mix.\n\n\n# example5.py\n\n\ufefffrom nose.tools import raises\nfrom hypothesis import given, assume\nfrom hypothesis.strategies import integers, floats, one_of\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(one_of(integers(), floats()))       # \n-----------\ndef test_div(x):\n    \nTest integers and floats.\n\ufeff\n    assume(x \n 0)\n    print x\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n    \nTest division by zero.\n\ufeff\ufeff\ufeff\n    division('4', 0)\n\n\n\n\nInterestingly adding floats causes some trouble with really large values\nlike 8.98846567431158e+307 in this example.\n\n\n$ nosetests example5.py\nF.\n======================================================================\nFAIL: example5.test_div\n----------------------------------------------------------------------\nTraceback (most recent call last):\n[...]\n    assert division(x*2, x) == 2.0\nAssertionError: \n-------------------- \n begin captured stdout \n ---------------------\n[...]\n2.38756119474e+307\n8.9873684495e+307\n8.98846567431e+307\nFalsifying example: test_div(x=8.98846567431158e+307)\n8.98846567431e+307\n--------------------- \n end captured stdout \n ----------------------\n----------------------------------------------------------------------\nRan 2 tests in 0.500s\nFAILED (failures=1)\n\n\n\n\nThe cause of the failure becomes obvious when one executes the mathematical\noperation in the Python shell.\n\n\n 8.98846567431158e+307*2/8.98846567431158e+307 == 2.0\nFalse\n\n\n 8.98846567431158e+307*2/8.98846567431158e+307\ninf\n\n\n 8.98846567431158e+307*2\ninf\n\n\n\n\nHypothesis is really good at finding such corner-cases. Although in this example\nit does not actually break the \ndivision()\n function, few people would have thought\nof this case without the help of Hypothesis. I certainly hadn't.\n\n\nI hope this article provided a very brief introduction to Hypothesis and what value\nit adds to testing Python code. Check out the Hypothesis documentation as there\nare many more features.\n\n\nI plan to add Hypothesis based testing to my Python projects\nsoon but I somehow fear the outcome ;-)", 
            "title": "Testing Python Code with Hypothesis"
        }, 
        {
            "location": "/testing_python_code_with_hypothesis/#testing-python-code-with-hypothesis", 
            "text": "According to its  web page  \"Hypothesis is a new generation\nof tools for automating your\ntesting process. It combines human understanding of your problem domain with machine\nintelligence to improve the quality of your testing process while spendingless time\nwriting tests.\" That sounds all nice and fancy but what does this in mean in practice?\nThis article provides a quick introduction to Hypothesis, just to whet your appetite.\nThe  official documentation \nprovides a more extensive tutorial.  Hypothesis is available on PyPi and can be easily installed through pip. Hypothesis\nworks in conjunction with a Python test suite. My personal preference is  Nose  but\nothers are supported, too.  $ pip install hypothesis nose\nCollecting hypothesis\nCollecting nose\n  Using cached nose-1.3.7-py2-none-any.whl\nCollecting enum34 (from hypothesis)\n  Using cached enum34-1.1.6-py2-none-any.whl\nInstalling collected packages: enum34, hypothesis, nose\nSuccessfully installed enum34-1.1.6 hypothesis-3.6.1 nose-1.3.7  For the purpose of this article I am going to explain how Hypothesis works with a\nsimple custom  division()  function that accepts numbers or strings containing numbers.\nI admit that this example is rather contrived but it serves the purpose of this article\nreally well. The first listing implements the test functions with some assistance\nof Nose.  # example1.py\nfrom nose.tools import raises\n\ndef division(x, y):\n    return float(x) / float(y)\n\ndef test_div():\n     Test numbers and strings. \n    assert division(4, 2.0) == division('4', '2.0')\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n     Test division by zero. \n    division('4', 0)  What is immediately obvious is that only a very limited set of possible arguments to division()  is tested. Most people can immediately think of additional combinations of\nintegers, floats and string representations worth testing.  $ nosetests example1.py \n..\n----------------------------------------------------------------------\nRan 2 tests in 0.000s\n\nOK  The second example adds tests for numbers from 1 to 10, also as floats and strings.  # example2.py\n\nfrom nose.tools import raises\n\ndef division(x, y):\n    return float(x) / float(y)\n\ndef check_division(x, y):\n    assert division(x, y) == 2.0\n\ndef test_div():\n     Test numbers and strings. \n    for i in range(1, 10):\n        yield division, i*2, i\n        yield division, float(i*2), i\n        yield division, i*2, float(i)\n        yield division, float(i*2), float(i)\n        yield division, i*2, str(i)\n        yield division, str(i*2), i\n        # and so forth...\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n     Test division by zero. \ufeff\ufeff\n    division('4', 0)  It covers many more combinations, but is still limited to a tiny subset of possible\nnumbers. It also doesn't look very elegant?  $ nosetests example2.py \n.......................................................\n----------------------------------------------------------------------\nRan 55 tests in 0.005s\nOK  Like the first example it provides a specific test case for the ZeroDivisionError\nexception. But are there any other special cases? Maybe Hypothesis can find one.  The key objective of Hypothesis is to generate input data for test functions. And\nit does so very cleverly. Let's rewrite the test and use Hypothesis. Through\nthe  @given  decorator Hypothesis will create a series of integers to the test.  # example3.py\n\nfrom nose.tools import raises\nfrom hypothesis import given\nfrom hypothesis.strategies import integers\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(x=integers())\ndef test_div(x):\n     Test integers. \n    print x               # show value of x, normally not done!\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n     Test division by zero. \ufeff\ufeff\n    division('4', 0)  Unfortunately the  @given(x=integers())  line introduces the ZeroDivisionError into\nthe test. This was bound to happen as 0 is a valid integer. Note that the output\nclearly shows what input caused the test to fail ( Falsifying example: ... ) and\nbecause of the print statement in the code it also shows the different other integer\nvalues Hypothesis tried.  $ nosetests example3.py \nE.\n======================================================================\nERROR: example3.test_div\n----------------------------------------------------------------------\nTraceback (most recent call last):\n[...]\nZeroDivisionError: float division by zero\n--------------------   begin captured stdout   ---------------------\n-86\n38698778983165550746815151433416776989\n130775184150007723213375339326718763618\n-149\n-60717049783932157206209978973119425965\n0\n0\n0\nFalsifying example: test_div(x=0)\n0\n---------------------   end captured stdout   ----------------------\n----------------------------------------------------------------------\nRan 2 tests in 0.011s\nFAILED (errors=1)  Quite clearly we have to amend the code to prevent Hypothesis causing the\nZeroDivisionError exception. The assume function serves this purpose.  # example4.py\n\nfrom nose.tools import raises\nfrom hypothesis import given, assume\nfrom hypothesis.strategies import integers\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(x=integers())\ndef test_div(x):\n     Test non-zero integers. \n    assume(x   0)                      #  -----------\n\n    print x    # show value of x, normally not done!\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n     Test division by zero. \n    division('4', 0)\nNow the tests pass.\n\n$ nosetests example4.py \n..\n----------------------------------------------------------------------\nRan 2 tests in 0.045s\nOK  But what about other numbers than integers? The next example adds floats to the mix.  # example5.py\n\n\ufefffrom nose.tools import raises\nfrom hypothesis import given, assume\nfrom hypothesis.strategies import integers, floats, one_of\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(one_of(integers(), floats()))       #  -----------\ndef test_div(x):\n     Test integers and floats. \ufeff\n    assume(x   0)\n    print x\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n     Test division by zero. \ufeff\ufeff\ufeff\n    division('4', 0)  Interestingly adding floats causes some trouble with really large values\nlike 8.98846567431158e+307 in this example.  $ nosetests example5.py\nF.\n======================================================================\nFAIL: example5.test_div\n----------------------------------------------------------------------\nTraceback (most recent call last):\n[...]\n    assert division(x*2, x) == 2.0\nAssertionError: \n--------------------   begin captured stdout   ---------------------\n[...]\n2.38756119474e+307\n8.9873684495e+307\n8.98846567431e+307\nFalsifying example: test_div(x=8.98846567431158e+307)\n8.98846567431e+307\n---------------------   end captured stdout   ----------------------\n----------------------------------------------------------------------\nRan 2 tests in 0.500s\nFAILED (failures=1)  The cause of the failure becomes obvious when one executes the mathematical\noperation in the Python shell.   8.98846567431158e+307*2/8.98846567431158e+307 == 2.0\nFalse  8.98846567431158e+307*2/8.98846567431158e+307\ninf  8.98846567431158e+307*2\ninf  Hypothesis is really good at finding such corner-cases. Although in this example\nit does not actually break the  division()  function, few people would have thought\nof this case without the help of Hypothesis. I certainly hadn't.  I hope this article provided a very brief introduction to Hypothesis and what value\nit adds to testing Python code. Check out the Hypothesis documentation as there\nare many more features.  I plan to add Hypothesis based testing to my Python projects\nsoon but I somehow fear the outcome ;-)", 
            "title": "Testing Python code with Hypothesis"
        }
    ]
}