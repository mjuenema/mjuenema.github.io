{
    "docs": [
        {
            "location": "/", 
            "text": "About Me\n\n\nMy career as an IT Systems, Network and Security Engineer spans over 20 years during\nwhich I have been involved in major projects in Australia and Germany.\n\n\nI have extensive knowledge of Linux/Unix systems as well as IP Networks while at the\nsame time I consider myself a reasonably good Python programmer.\n\n\nCheck out my \nLinkedIn\n profile for\nmore information.\n\n\nProjects and Notes\n\n\nBelow are a list of notes and projects I have been working on. I use this page mainly \nfor my own reference but other people might find something useful.\n\n\nDevOps and Cloud Computing\n\n\n\n\n'Terraform: Up \n Running' code samples translated\n\n\n'Infrastructure as Python Code' (IaPyC)\n\n\n\n\nSoftware Development\n\n\n\n\nMy collection of Python notebooks\n\n\nTesting Python Code with Hypothesis\n\n\n\n\nNetworking\n\n\n\n\nInstalling GNS3 on CentOS 7\n\n\nBasic IPv6 on Cisco IOS\n\n\n802.11s Wireless Mesh Network\n\n\n\n\nInternet of Things (IoT)\n\n\n\n\nPycom SiPy and Sigfox\n\n\nCryptography and Low-Power Wide Area networks (LPWAN)", 
            "title": "Home"
        }, 
        {
            "location": "/#about-me", 
            "text": "My career as an IT Systems, Network and Security Engineer spans over 20 years during\nwhich I have been involved in major projects in Australia and Germany.  I have extensive knowledge of Linux/Unix systems as well as IP Networks while at the\nsame time I consider myself a reasonably good Python programmer.  Check out my  LinkedIn  profile for\nmore information.", 
            "title": "About Me"
        }, 
        {
            "location": "/#projects-and-notes", 
            "text": "Below are a list of notes and projects I have been working on. I use this page mainly \nfor my own reference but other people might find something useful.", 
            "title": "Projects and Notes"
        }, 
        {
            "location": "/#devops-and-cloud-computing", 
            "text": "'Terraform: Up   Running' code samples translated  'Infrastructure as Python Code' (IaPyC)", 
            "title": "DevOps and Cloud Computing"
        }, 
        {
            "location": "/#software-development", 
            "text": "My collection of Python notebooks  Testing Python Code with Hypothesis", 
            "title": "Software Development"
        }, 
        {
            "location": "/#networking", 
            "text": "Installing GNS3 on CentOS 7  Basic IPv6 on Cisco IOS  802.11s Wireless Mesh Network", 
            "title": "Networking"
        }, 
        {
            "location": "/#internet-of-things-iot", 
            "text": "Pycom SiPy and Sigfox  Cryptography and Low-Power Wide Area networks (LPWAN)", 
            "title": "Internet of Things (IoT)"
        }, 
        {
            "location": "/installing_gns3_on_centos7/", 
            "text": "Installing GNS3 on CentOS 7\n\n\nGNS3 is a popular network software emulator. It uses the Dynamips emulation software\nto simulate Cisco IOS. The official documentation includes installation guides for\nUbuntu, Debian, Arch Linux, Fedora and OpenSuse. This article explains how to install\nGNS3 on CentOS 7.\n\n\nRequirements\n\n\nGNS3 is written in Python 3, Python 2 is not supported. The Python 3 packages are not\navailable through the CentOS RPM repositories but they are available on EPEL.\nThe steps below add the EPEL repository, install Python 3.4, QT5 and various other\npackages that are either needed or are useful for running GNS3.\n\n\nsudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\nsudo yum install python34 python34-devel python34-setuptools python34-tools\nsudo yum install elfutils-libelf-devel libpcap-devel cmake glibc-static qemu telnet gnome-terminal putty\nsudo yum install qt5-qtbase qt5-qtbase-devel qt5-qtsvg qt5-qtsvg-devel\nsudo yum groupinstall Fonts\ncurl https://bootstrap.pypa.io/get-pip.py | sudo python3.4\n\n\n\n\nGNS3\n\n\nOnce Python 3.4 has been installed, the latest GNS3 releases are available from PyPi \nand are easily installed through the pip3.4 script.\n\n\nsudo pip3.4 install gns3-server gns3-gui\n\n\n\n\nQt5 and Python 3 bindings\n\n\nGNS3 relies on the Python 3 bindings for the QT5 toolkit. These are not available for\nCentOS 7 from any repository and must be installed from source code. This section is\nheavily based on the instructions found at \n\nhttp://robertbasic.com/blog/install-pyqt5-in-python-3-virtual-environment/\n.\n\n\nSIP\n\n\ncd /tmp\nwget http://sourceforge.net/projects/pyqt/files/sip/sip-4.16.5/sip-4.16.5.tar.gz\ntar xvfz sip-4.16.5.tar.gz\ncd sip-4.16.5\npython3.4 configure.py\nmake\nsudo make install\n\n\n\n\n\nPyQt5\n\n\nBuilding PyQt5 from source will take a while.\n\n\ncd /tmp\nwget http://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4/PyQt-gpl-5.4.tar.gz\ntar xzf PyQt-gpl-5.4.tar.gz\ncd PyQt-gpl-5.4\npython3.4 configure.py --qmake /usr/bin/qmake-qt5\nmake\nsudo make install\n\n\n\n\n\nDynamips\n\n\nDynamips is a Cisco router emulator. It started as a separate project in 2005 but the\nsources are now part of the GNS3 repositories on Github.\n\n\ncd /tmp\ngit clone https://github.com/GNS3/dynamips.git\ncd dynamips/\nmkdir build\ncd build/\ncmake .. -DDYNAMIPS_CODE=stable\nmake\nsudo make install\n\n\n\n\n\nVPCS\n\n\nThe Virtual PC Simulator (VPCS) can be used in GNS3 to add simple PCs to a network\ntopology. The steps below will install the /usr/local/bin/vpcs from source code.\n\n\ncd /tmp\nsvn checkout http://svn.code.sf.net/p/vpcs/code/trunk vpcs\ncd vpcs/src\n./mk.sh 64\nsudo install -m 755 vpcs /usr/local/bin\n\n\n\n\n\nThat's all.", 
            "title": "Installing GNS3 on CentOS 7"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#installing-gns3-on-centos-7", 
            "text": "GNS3 is a popular network software emulator. It uses the Dynamips emulation software\nto simulate Cisco IOS. The official documentation includes installation guides for\nUbuntu, Debian, Arch Linux, Fedora and OpenSuse. This article explains how to install\nGNS3 on CentOS 7.", 
            "title": "Installing GNS3 on CentOS 7"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#requirements", 
            "text": "GNS3 is written in Python 3, Python 2 is not supported. The Python 3 packages are not\navailable through the CentOS RPM repositories but they are available on EPEL.\nThe steps below add the EPEL repository, install Python 3.4, QT5 and various other\npackages that are either needed or are useful for running GNS3.  sudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\nsudo yum install python34 python34-devel python34-setuptools python34-tools\nsudo yum install elfutils-libelf-devel libpcap-devel cmake glibc-static qemu telnet gnome-terminal putty\nsudo yum install qt5-qtbase qt5-qtbase-devel qt5-qtsvg qt5-qtsvg-devel\nsudo yum groupinstall Fonts\ncurl https://bootstrap.pypa.io/get-pip.py | sudo python3.4", 
            "title": "Requirements"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#gns3", 
            "text": "Once Python 3.4 has been installed, the latest GNS3 releases are available from PyPi \nand are easily installed through the pip3.4 script.  sudo pip3.4 install gns3-server gns3-gui", 
            "title": "GNS3"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#qt5-and-python-3-bindings", 
            "text": "GNS3 relies on the Python 3 bindings for the QT5 toolkit. These are not available for\nCentOS 7 from any repository and must be installed from source code. This section is\nheavily based on the instructions found at  http://robertbasic.com/blog/install-pyqt5-in-python-3-virtual-environment/ .", 
            "title": "Qt5 and Python 3 bindings"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#sip", 
            "text": "cd /tmp\nwget http://sourceforge.net/projects/pyqt/files/sip/sip-4.16.5/sip-4.16.5.tar.gz\ntar xvfz sip-4.16.5.tar.gz\ncd sip-4.16.5\npython3.4 configure.py\nmake\nsudo make install", 
            "title": "SIP"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#pyqt5", 
            "text": "Building PyQt5 from source will take a while.  cd /tmp\nwget http://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4/PyQt-gpl-5.4.tar.gz\ntar xzf PyQt-gpl-5.4.tar.gz\ncd PyQt-gpl-5.4\npython3.4 configure.py --qmake /usr/bin/qmake-qt5\nmake\nsudo make install", 
            "title": "PyQt5"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#dynamips", 
            "text": "Dynamips is a Cisco router emulator. It started as a separate project in 2005 but the\nsources are now part of the GNS3 repositories on Github.  cd /tmp\ngit clone https://github.com/GNS3/dynamips.git\ncd dynamips/\nmkdir build\ncd build/\ncmake .. -DDYNAMIPS_CODE=stable\nmake\nsudo make install", 
            "title": "Dynamips"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#vpcs", 
            "text": "The Virtual PC Simulator (VPCS) can be used in GNS3 to add simple PCs to a network\ntopology. The steps below will install the /usr/local/bin/vpcs from source code.  cd /tmp\nsvn checkout http://svn.code.sf.net/p/vpcs/code/trunk vpcs\ncd vpcs/src\n./mk.sh 64\nsudo install -m 755 vpcs /usr/local/bin  That's all.", 
            "title": "VPCS"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/", 
            "text": "Basic IPv6 on Cisco IOS\n\n\nGlobal settings\n\n\nThere are a couple of global settings that enable IPv6 on a Cisco router. The example below also shows two host name to IPv6 address mappings.\n\n\nip routing\nipv6 unicast-routing\n\nip cef\nipv6 cef\n\nipv6 host R1 FDFC:38C4:F0BE:FFFF::1\nipv6 host R2 FDFC:38C4:F0BE:FFFF::2\n\n\n\n\nInterfaces\n\n\nThe example below shows a dual-stack configuration for an Ethernet interface. \n\nFDFC:38C4:F0BE/48\n is the unique-local address (ULA) prefix registered with \nthe \nIPv6 ULA (Unique Local Address) RFC4193 Registration List\n.\nThe IPv6 subnet on this interface is \n...:1::...\n and the host address is \n...::1\n.\n\n\n# sh run int e1/0\ninterface Ethernet1/0\n ip address 192.168.1.1 255.255.255.0\n ipv6 address FDFC:38C4:F0BE:1::1/64\n ipv6 enable\n\n\n\n\nThe loopback interface is on IPv6 subnet \nFFFF\n. Like its IPv4 address, \nits IPv6 address has a netmask with all bits set (/128).\n\n\n# sh run int lo0\ninterface Loopback0\n ip address 192.168.255.1 255.255.255.255\n ipv6 address FDFC:38C4:F0BE:FFFF::1/128\n ipv6 enable\n\n\n\n\nThe show ipv6 interface command displays IPv6 information for that interface\n\n\n# sh ipv6 interface e1/0\nEthernet1/0 is up, line protocol is up\n  IPv6 is enabled, link-local address is FE80::C801:32FF:FE70:1C\n  Global unicast address(es):\n    FDFC:38C4:F0BE:1::1, subnet is FDFC:38C4:F0BE:1::/64\n  Joined group address(es):\n    FF02::1\n    FF02::2\n    FF02::1:FF00:1\n    FF02::1:FF70:1C\n  MTU is 1500 bytes\n  ICMP error messages limited to one every 100 milliseconds\n  ICMP redirects are enabled\n  ND DAD is enabled, number of DAD attempts: 1\n  ND reachable time is 30000 milliseconds\n  ND advertised reachable time is 0 milliseconds\n  ND advertised retransmit interval is 0 milliseconds\n  ND router advertisements are sent every 200 seconds\n  ND router advertisements live for 1800 seconds\n  Hosts use stateless autoconfig for addresses.\n192.168.1.1/24 (IPv4)\nFDFC:38C4:F0BE:1::1/64 (IPv6 unique-local address; ULA)\nFE80::... (IPv6 link local)\nff02::1 (All nodes on the local network segment)\nFF02::2 (All routers on the local network segment)\nFF02::1:FF00:1 (Solicited-node multicast address; used for Neighbour-Disovery)\nFF02::1:FF70:1C (???)\n\n\n\n\nShow IPv6 ...\n\n\nNeighbor Cache\n\n\n# sh ipv6 neighbors [e1/0]\nIPv6 Address                              Age Link-layer Addr State Interface\nFE80::C802:32FF:FE7F:1C                     0 ca02.327f.001c  REACH Et1/0\nFDFC:38C4:F0BE:1::2                         0 ca02.327f.001c  STALE Et1/0\n\n\n\n\nRoutes\n\n\n# sh ipv6 route\nIPv6 Routing Table - 6 entries\nCodes: C - Connected, L - Local, S - Static, R - RIP, B - BGP\n       U - Per-user Static route\n       I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea, IS - ISIS summary\n       O - OSPF intra, OI - OSPF inter, OE1 - OSPF ext 1, OE2 - OSPF ext 2\n       ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2\nC   FDFC:38C4:F0BE:1::/64 [0/0]\n     via ::, Ethernet1/0\nL   FDFC:38C4:F0BE:1::1/128 [0/0]\n     via ::, Ethernet1/0\nC   FDFC:38C4:F0BE:4::/64 [0/0]\n     via ::, Ethernet1/1\nL   FDFC:38C4:F0BE:4::1/128 [0/0]\n     via ::, Ethernet1/1\nL   FE80::/10 [0/0]\n     via ::, Null0\nL   FF00::/8 [0/0]\n     via ::, Null0\n\n\n\n\nOSPFv3\n\n\nOSPFv3 expands on OSPF version 2 to provide support for IPv6 routing prefixes and\nthe larger size of IPv6 addresses. In regards to configuring OSPFv3 on Cisco IOS there\nare two key differences to OSPFv2.\n\n\n\n\nIn OSPFv3, a routing process does not need to be explicitly created. Enabling OSPFv3\n  on an interface will cause a routing process, and its associated configuration,\n  to be created. One may still want to customise OSPFv3 parameters that are not\n  interface specific.\n\n\nIn OSPFv3, each interface must be enabled using commands in interface configuration\n  mode. This feature is different from OSPF version 2, in which interfaces are\n  indirectly enabled using the device configuration mode.\n\n\n\n\nOSPFv3 can be used for IPv6 and IPv4 as long as separate OSPF processes are used.\nYou may want to use OSPFv2 for IPv4 and OSPFv3 only for IPv6. The example below\nconfigures a single OSPFv3 zone for IPv6 only.\n\n\nEnabling OSPFv3 authentication is so simple that there is no reason for not doing so.\n\n\n# sh run\ninterface Ethernet1/0\n  ...\n  ipv6 ospf 1 area 0\n\nipv6 router ospf 1\n log-adjacency-changes\n redistribute connected\n area 0 authentication ipsec spi 1000 md5 8B800BD784E62C8C8B0A8DEA3451A25E", 
            "title": "Basic IPv6 on Cisco IOS"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#basic-ipv6-on-cisco-ios", 
            "text": "", 
            "title": "Basic IPv6 on Cisco IOS"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#global-settings", 
            "text": "There are a couple of global settings that enable IPv6 on a Cisco router. The example below also shows two host name to IPv6 address mappings.  ip routing\nipv6 unicast-routing\n\nip cef\nipv6 cef\n\nipv6 host R1 FDFC:38C4:F0BE:FFFF::1\nipv6 host R2 FDFC:38C4:F0BE:FFFF::2", 
            "title": "Global settings"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#interfaces", 
            "text": "The example below shows a dual-stack configuration for an Ethernet interface.  FDFC:38C4:F0BE/48  is the unique-local address (ULA) prefix registered with \nthe  IPv6 ULA (Unique Local Address) RFC4193 Registration List .\nThe IPv6 subnet on this interface is  ...:1::...  and the host address is  ...::1 .  # sh run int e1/0\ninterface Ethernet1/0\n ip address 192.168.1.1 255.255.255.0\n ipv6 address FDFC:38C4:F0BE:1::1/64\n ipv6 enable  The loopback interface is on IPv6 subnet  FFFF . Like its IPv4 address, \nits IPv6 address has a netmask with all bits set (/128).  # sh run int lo0\ninterface Loopback0\n ip address 192.168.255.1 255.255.255.255\n ipv6 address FDFC:38C4:F0BE:FFFF::1/128\n ipv6 enable  The show ipv6 interface command displays IPv6 information for that interface  # sh ipv6 interface e1/0\nEthernet1/0 is up, line protocol is up\n  IPv6 is enabled, link-local address is FE80::C801:32FF:FE70:1C\n  Global unicast address(es):\n    FDFC:38C4:F0BE:1::1, subnet is FDFC:38C4:F0BE:1::/64\n  Joined group address(es):\n    FF02::1\n    FF02::2\n    FF02::1:FF00:1\n    FF02::1:FF70:1C\n  MTU is 1500 bytes\n  ICMP error messages limited to one every 100 milliseconds\n  ICMP redirects are enabled\n  ND DAD is enabled, number of DAD attempts: 1\n  ND reachable time is 30000 milliseconds\n  ND advertised reachable time is 0 milliseconds\n  ND advertised retransmit interval is 0 milliseconds\n  ND router advertisements are sent every 200 seconds\n  ND router advertisements live for 1800 seconds\n  Hosts use stateless autoconfig for addresses.\n192.168.1.1/24 (IPv4)\nFDFC:38C4:F0BE:1::1/64 (IPv6 unique-local address; ULA)\nFE80::... (IPv6 link local)\nff02::1 (All nodes on the local network segment)\nFF02::2 (All routers on the local network segment)\nFF02::1:FF00:1 (Solicited-node multicast address; used for Neighbour-Disovery)\nFF02::1:FF70:1C (???)", 
            "title": "Interfaces"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#show-ipv6", 
            "text": "", 
            "title": "Show IPv6 ..."
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#neighbor-cache", 
            "text": "# sh ipv6 neighbors [e1/0]\nIPv6 Address                              Age Link-layer Addr State Interface\nFE80::C802:32FF:FE7F:1C                     0 ca02.327f.001c  REACH Et1/0\nFDFC:38C4:F0BE:1::2                         0 ca02.327f.001c  STALE Et1/0", 
            "title": "Neighbor Cache"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#routes", 
            "text": "# sh ipv6 route\nIPv6 Routing Table - 6 entries\nCodes: C - Connected, L - Local, S - Static, R - RIP, B - BGP\n       U - Per-user Static route\n       I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea, IS - ISIS summary\n       O - OSPF intra, OI - OSPF inter, OE1 - OSPF ext 1, OE2 - OSPF ext 2\n       ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2\nC   FDFC:38C4:F0BE:1::/64 [0/0]\n     via ::, Ethernet1/0\nL   FDFC:38C4:F0BE:1::1/128 [0/0]\n     via ::, Ethernet1/0\nC   FDFC:38C4:F0BE:4::/64 [0/0]\n     via ::, Ethernet1/1\nL   FDFC:38C4:F0BE:4::1/128 [0/0]\n     via ::, Ethernet1/1\nL   FE80::/10 [0/0]\n     via ::, Null0\nL   FF00::/8 [0/0]\n     via ::, Null0", 
            "title": "Routes"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#ospfv3", 
            "text": "OSPFv3 expands on OSPF version 2 to provide support for IPv6 routing prefixes and\nthe larger size of IPv6 addresses. In regards to configuring OSPFv3 on Cisco IOS there\nare two key differences to OSPFv2.   In OSPFv3, a routing process does not need to be explicitly created. Enabling OSPFv3\n  on an interface will cause a routing process, and its associated configuration,\n  to be created. One may still want to customise OSPFv3 parameters that are not\n  interface specific.  In OSPFv3, each interface must be enabled using commands in interface configuration\n  mode. This feature is different from OSPF version 2, in which interfaces are\n  indirectly enabled using the device configuration mode.   OSPFv3 can be used for IPv6 and IPv4 as long as separate OSPF processes are used.\nYou may want to use OSPFv2 for IPv4 and OSPFv3 only for IPv6. The example below\nconfigures a single OSPFv3 zone for IPv6 only.  Enabling OSPFv3 authentication is so simple that there is no reason for not doing so.  # sh run\ninterface Ethernet1/0\n  ...\n  ipv6 ospf 1 area 0\n\nipv6 router ospf 1\n log-adjacency-changes\n redistribute connected\n area 0 authentication ipsec spi 1000 md5 8B800BD784E62C8C8B0A8DEA3451A25E", 
            "title": "OSPFv3"
        }, 
        {
            "location": "/testing_python_code_with_hypothesis/", 
            "text": "Testing Python code with Hypothesis\n\n\nAccording to its \nweb page\n \"Hypothesis is a new generation\nof tools for automating your\ntesting process. It combines human understanding of your problem domain with machine\nintelligence to improve the quality of your testing process while spendingless time\nwriting tests.\" That sounds all nice and fancy but what does this in mean in practice?\nThis article provides a quick introduction to Hypothesis, just to whet your appetite.\nThe \nofficial documentation\n\nprovides a more extensive tutorial.\n\n\nHypothesis is available on PyPi and can be easily installed through pip. Hypothesis\nworks in conjunction with a Python test suite. My personal preference is \n\nNose\n but\nothers are supported, too.\n\n\n$ pip install hypothesis nose\nCollecting hypothesis\nCollecting nose\n  Using cached nose-1.3.7-py2-none-any.whl\nCollecting enum34 (from hypothesis)\n  Using cached enum34-1.1.6-py2-none-any.whl\nInstalling collected packages: enum34, hypothesis, nose\nSuccessfully installed enum34-1.1.6 hypothesis-3.6.1 nose-1.3.7\n\n\n\n\nFor the purpose of this article I am going to explain how Hypothesis works with a\nsimple custom \ndivision()\n function that accepts numbers or strings containing numbers.\nI admit that this example is rather contrived but it serves the purpose of this article\nreally well. The first listing implements the test functions with some assistance\nof Nose.\n\n\n# example1.py\nfrom nose.tools import raises\n\ndef division(x, y):\n    return float(x) / float(y)\n\ndef test_div():\n    \nTest numbers and strings.\n\n    assert division(4, 2.0) == division('4', '2.0')\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n    \nTest division by zero.\n\n    division('4', 0)\n\n\n\n\nWhat is immediately obvious is that only a very limited set of possible arguments to\n\ndivision()\n is tested. Most people can immediately think of additional combinations of\nintegers, floats and string representations worth testing.\n\n\n$ nosetests example1.py \n..\n----------------------------------------------------------------------\nRan 2 tests in 0.000s\n\nOK\n\n\n\n\nThe second example adds tests for numbers from 1 to 10, also as floats and strings.\n\n\n# example2.py\n\nfrom nose.tools import raises\n\ndef division(x, y):\n    return float(x) / float(y)\n\ndef check_division(x, y):\n    assert division(x, y) == 2.0\n\ndef test_div():\n    \nTest numbers and strings.\n\n    for i in range(1, 10):\n        yield division, i*2, i\n        yield division, float(i*2), i\n        yield division, i*2, float(i)\n        yield division, float(i*2), float(i)\n        yield division, i*2, str(i)\n        yield division, str(i*2), i\n        # and so forth...\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n    \nTest division by zero.\n\ufeff\ufeff\n    division('4', 0)\n\n\n\n\nIt covers many more combinations, but is still limited to a tiny subset of possible\nnumbers. It also doesn't look very elegant?\n\n\n$ nosetests example2.py \n.......................................................\n----------------------------------------------------------------------\nRan 55 tests in 0.005s\nOK\n\n\n\n\nLike the first example it provides a specific test case for the ZeroDivisionError\nexception. But are there any other special cases? Maybe Hypothesis can find one.\n\n\nThe key objective of Hypothesis is to generate input data for test functions. And\nit does so very cleverly. Let's rewrite the test and use Hypothesis. Through\nthe \n@given\n decorator Hypothesis will create a series of integers to the test.\n\n\n# example3.py\n\nfrom nose.tools import raises\nfrom hypothesis import given\nfrom hypothesis.strategies import integers\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(x=integers())\ndef test_div(x):\n    \nTest integers.\n\n    print x               # show value of x, normally not done!\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n    \nTest division by zero.\n\ufeff\ufeff\n    division('4', 0)\n\n\n\n\nUnfortunately the \n@given(x=integers())\n line introduces the ZeroDivisionError into\nthe test. This was bound to happen as 0 is a valid integer. Note that the output\nclearly shows what input caused the test to fail (\nFalsifying example: ...\n) and\nbecause of the print statement in the code it also shows the different other integer\nvalues Hypothesis tried.\n\n\n$ nosetests example3.py \nE.\n======================================================================\nERROR: example3.test_div\n----------------------------------------------------------------------\nTraceback (most recent call last):\n[...]\nZeroDivisionError: float division by zero\n-------------------- \n begin captured stdout \n ---------------------\n-86\n38698778983165550746815151433416776989\n130775184150007723213375339326718763618\n-149\n-60717049783932157206209978973119425965\n0\n0\n0\nFalsifying example: test_div(x=0)\n0\n--------------------- \n end captured stdout \n ----------------------\n----------------------------------------------------------------------\nRan 2 tests in 0.011s\nFAILED (errors=1)\n\n\n\n\nQuite clearly we have to amend the code to prevent Hypothesis causing the\nZeroDivisionError exception. The assume function serves this purpose.\n\n\n# example4.py\n\nfrom nose.tools import raises\nfrom hypothesis import given, assume\nfrom hypothesis.strategies import integers\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(x=integers())\ndef test_div(x):\n    \nTest non-zero integers.\n\n    assume(x \n 0)                      # \n-----------\n\n    print x    # show value of x, normally not done!\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n    \nTest division by zero.\n\n    division('4', 0)\nNow the tests pass.\n\n$ nosetests example4.py \n..\n----------------------------------------------------------------------\nRan 2 tests in 0.045s\nOK\n\n\n\n\nBut what about other numbers than integers? The next example adds floats to the mix.\n\n\n# example5.py\n\n\ufefffrom nose.tools import raises\nfrom hypothesis import given, assume\nfrom hypothesis.strategies import integers, floats, one_of\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(one_of(integers(), floats()))       # \n-----------\ndef test_div(x):\n    \nTest integers and floats.\n\ufeff\n    assume(x \n 0)\n    print x\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n    \nTest division by zero.\n\ufeff\ufeff\ufeff\n    division('4', 0)\n\n\n\n\nInterestingly adding floats causes some trouble with really large values\nlike 8.98846567431158e+307 in this example.\n\n\n$ nosetests example5.py\nF.\n======================================================================\nFAIL: example5.test_div\n----------------------------------------------------------------------\nTraceback (most recent call last):\n[...]\n    assert division(x*2, x) == 2.0\nAssertionError: \n-------------------- \n begin captured stdout \n ---------------------\n[...]\n2.38756119474e+307\n8.9873684495e+307\n8.98846567431e+307\nFalsifying example: test_div(x=8.98846567431158e+307)\n8.98846567431e+307\n--------------------- \n end captured stdout \n ----------------------\n----------------------------------------------------------------------\nRan 2 tests in 0.500s\nFAILED (failures=1)\n\n\n\n\nThe cause of the failure becomes obvious when one executes the mathematical\noperation in the Python shell.\n\n\n 8.98846567431158e+307*2/8.98846567431158e+307 == 2.0\nFalse\n\n\n 8.98846567431158e+307*2/8.98846567431158e+307\ninf\n\n\n 8.98846567431158e+307*2\ninf\n\n\n\n\nHypothesis is really good at finding such corner-cases. Although in this example\nit does not actually break the \ndivision()\n function, few people would have thought\nof this case without the help of Hypothesis. I certainly hadn't.\n\n\nI hope this article provided a very brief introduction to Hypothesis and what value\nit adds to testing Python code. Check out the Hypothesis documentation as there\nare many more features.\n\n\nI plan to add Hypothesis based testing to my Python projects\nsoon but I somehow fear the outcome ;-)", 
            "title": "Testing Python Code with Hypothesis"
        }, 
        {
            "location": "/testing_python_code_with_hypothesis/#testing-python-code-with-hypothesis", 
            "text": "According to its  web page  \"Hypothesis is a new generation\nof tools for automating your\ntesting process. It combines human understanding of your problem domain with machine\nintelligence to improve the quality of your testing process while spendingless time\nwriting tests.\" That sounds all nice and fancy but what does this in mean in practice?\nThis article provides a quick introduction to Hypothesis, just to whet your appetite.\nThe  official documentation \nprovides a more extensive tutorial.  Hypothesis is available on PyPi and can be easily installed through pip. Hypothesis\nworks in conjunction with a Python test suite. My personal preference is  Nose  but\nothers are supported, too.  $ pip install hypothesis nose\nCollecting hypothesis\nCollecting nose\n  Using cached nose-1.3.7-py2-none-any.whl\nCollecting enum34 (from hypothesis)\n  Using cached enum34-1.1.6-py2-none-any.whl\nInstalling collected packages: enum34, hypothesis, nose\nSuccessfully installed enum34-1.1.6 hypothesis-3.6.1 nose-1.3.7  For the purpose of this article I am going to explain how Hypothesis works with a\nsimple custom  division()  function that accepts numbers or strings containing numbers.\nI admit that this example is rather contrived but it serves the purpose of this article\nreally well. The first listing implements the test functions with some assistance\nof Nose.  # example1.py\nfrom nose.tools import raises\n\ndef division(x, y):\n    return float(x) / float(y)\n\ndef test_div():\n     Test numbers and strings. \n    assert division(4, 2.0) == division('4', '2.0')\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n     Test division by zero. \n    division('4', 0)  What is immediately obvious is that only a very limited set of possible arguments to division()  is tested. Most people can immediately think of additional combinations of\nintegers, floats and string representations worth testing.  $ nosetests example1.py \n..\n----------------------------------------------------------------------\nRan 2 tests in 0.000s\n\nOK  The second example adds tests for numbers from 1 to 10, also as floats and strings.  # example2.py\n\nfrom nose.tools import raises\n\ndef division(x, y):\n    return float(x) / float(y)\n\ndef check_division(x, y):\n    assert division(x, y) == 2.0\n\ndef test_div():\n     Test numbers and strings. \n    for i in range(1, 10):\n        yield division, i*2, i\n        yield division, float(i*2), i\n        yield division, i*2, float(i)\n        yield division, float(i*2), float(i)\n        yield division, i*2, str(i)\n        yield division, str(i*2), i\n        # and so forth...\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n     Test division by zero. \ufeff\ufeff\n    division('4', 0)  It covers many more combinations, but is still limited to a tiny subset of possible\nnumbers. It also doesn't look very elegant?  $ nosetests example2.py \n.......................................................\n----------------------------------------------------------------------\nRan 55 tests in 0.005s\nOK  Like the first example it provides a specific test case for the ZeroDivisionError\nexception. But are there any other special cases? Maybe Hypothesis can find one.  The key objective of Hypothesis is to generate input data for test functions. And\nit does so very cleverly. Let's rewrite the test and use Hypothesis. Through\nthe  @given  decorator Hypothesis will create a series of integers to the test.  # example3.py\n\nfrom nose.tools import raises\nfrom hypothesis import given\nfrom hypothesis.strategies import integers\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(x=integers())\ndef test_div(x):\n     Test integers. \n    print x               # show value of x, normally not done!\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n     Test division by zero. \ufeff\ufeff\n    division('4', 0)  Unfortunately the  @given(x=integers())  line introduces the ZeroDivisionError into\nthe test. This was bound to happen as 0 is a valid integer. Note that the output\nclearly shows what input caused the test to fail ( Falsifying example: ... ) and\nbecause of the print statement in the code it also shows the different other integer\nvalues Hypothesis tried.  $ nosetests example3.py \nE.\n======================================================================\nERROR: example3.test_div\n----------------------------------------------------------------------\nTraceback (most recent call last):\n[...]\nZeroDivisionError: float division by zero\n--------------------   begin captured stdout   ---------------------\n-86\n38698778983165550746815151433416776989\n130775184150007723213375339326718763618\n-149\n-60717049783932157206209978973119425965\n0\n0\n0\nFalsifying example: test_div(x=0)\n0\n---------------------   end captured stdout   ----------------------\n----------------------------------------------------------------------\nRan 2 tests in 0.011s\nFAILED (errors=1)  Quite clearly we have to amend the code to prevent Hypothesis causing the\nZeroDivisionError exception. The assume function serves this purpose.  # example4.py\n\nfrom nose.tools import raises\nfrom hypothesis import given, assume\nfrom hypothesis.strategies import integers\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(x=integers())\ndef test_div(x):\n     Test non-zero integers. \n    assume(x   0)                      #  -----------\n\n    print x    # show value of x, normally not done!\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n     Test division by zero. \n    division('4', 0)\nNow the tests pass.\n\n$ nosetests example4.py \n..\n----------------------------------------------------------------------\nRan 2 tests in 0.045s\nOK  But what about other numbers than integers? The next example adds floats to the mix.  # example5.py\n\n\ufefffrom nose.tools import raises\nfrom hypothesis import given, assume\nfrom hypothesis.strategies import integers, floats, one_of\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(one_of(integers(), floats()))       #  -----------\ndef test_div(x):\n     Test integers and floats. \ufeff\n    assume(x   0)\n    print x\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n     Test division by zero. \ufeff\ufeff\ufeff\n    division('4', 0)  Interestingly adding floats causes some trouble with really large values\nlike 8.98846567431158e+307 in this example.  $ nosetests example5.py\nF.\n======================================================================\nFAIL: example5.test_div\n----------------------------------------------------------------------\nTraceback (most recent call last):\n[...]\n    assert division(x*2, x) == 2.0\nAssertionError: \n--------------------   begin captured stdout   ---------------------\n[...]\n2.38756119474e+307\n8.9873684495e+307\n8.98846567431e+307\nFalsifying example: test_div(x=8.98846567431158e+307)\n8.98846567431e+307\n---------------------   end captured stdout   ----------------------\n----------------------------------------------------------------------\nRan 2 tests in 0.500s\nFAILED (failures=1)  The cause of the failure becomes obvious when one executes the mathematical\noperation in the Python shell.   8.98846567431158e+307*2/8.98846567431158e+307 == 2.0\nFalse  8.98846567431158e+307*2/8.98846567431158e+307\ninf  8.98846567431158e+307*2\ninf  Hypothesis is really good at finding such corner-cases. Although in this example\nit does not actually break the  division()  function, few people would have thought\nof this case without the help of Hypothesis. I certainly hadn't.  I hope this article provided a very brief introduction to Hypothesis and what value\nit adds to testing Python code. Check out the Hypothesis documentation as there\nare many more features.  I plan to add Hypothesis based testing to my Python projects\nsoon but I somehow fear the outcome ;-)", 
            "title": "Testing Python code with Hypothesis"
        }, 
        {
            "location": "/80211s_wireless_mesh/", 
            "text": "802.11s Wireless Mesh Network\n\n\nThis document is work in progress\n\n\nOverview\n\n\nOriginally the 802.11 WiFi standards defined two modes of operation, \n\"ad-hoc\" and \"infrastructure\".\nThe 802.11s amendment introduces another mode: mesh networks.\nThe distinguishing feature of mesh networks is that each node is able to forward\n802.11 frames to other nodes, potentially extending the range of the overall\nnetwork. This is different from \"infrastructure mode\" where all nodes communicate\nvia a central Access Point.\n\n\n\n\nNodes in a wireless mesh network may be mobile and it is the task of a (OSI layer 2)\nmesh routing protocols to continuously determine the optimal path between any two\nmesh nodes. The 802.11s document mandates the \n\nHybrid Wireless Mesh Protocol (HWMP)\n\nas the standard routing protocol but others can be implemented.\n\n\nIn this document I am going to describe how to configure a small wireless mesh network\nbased on the open80211s implementation on a few RaspberryPi.\n\n\nHardware \n Software\n\n\nThe following hardware and software was used for this experiment.\n\n\n\n\nMultiple RaspberryPi (various models) serving as Wireless Mesh Nodes and clients.\n\n\nelement14 WIPI WLAN USB Module\n\n  for Raspberry Pi as it supports mesh mode.\n\n\n\n\nConfiguring open80211s\n\n\nIn this section I am going to focus on how to get an 802.11s mesh network up and\nrunning using the \n\nopen80211s\n\nsoftware. open80211s is an open-source implementation\nof the recently ratified IEEE 802.11s wireless mesh standard. The project's Wiki\npage provides a lot of background information about 802.11s and the steps summarised\nin this document are based on the Wiki page.\n\n\nThe 2016-05-27-raspbian-jessie-lite.img version of Raspbian serves as the base for\nmy experiments with the open80211s software. It is good practice to update the\ndistribution first.\n\n\n$ sudo apt-get update\n$ sudo apt-get dist-upgrade\n$ reboot\n\n$ uname -a\nLinux yellow 4.4.13+ #894 Mon Jun 13 12:43:26 BST 2016 armv6l GNU/Linux\n\n\n\n\nKernel support\n\n\nThe WiPi USB WLAN adapter uses a RT5370 chip which is supported through the \n\nRT2800 driver\n. Most importantly is uses the\nmac80211 module which is a pre-requisite for open80211s to work.\n\n\n$ lsusb\nBus 001 Device 005: ID 148f:5370 Ralink Technology, Corp. RT5370 Wireless Adapter\n...\n\n$ sudo modprobe rt2800usb\n\n$ lsmod | grep 2800\nrt2800usb              18877  0\nrt2800lib              82155  1 rt2800usb\nrt2x00usb              12680  1 rt2800usb\nrt2x00lib              48998  3 rt2x00usb,rt2800lib,rt2800usb\nmac80211              608549  3 rt2x00lib,rt2x00usb,rt2800lib\ncrc_ccitt               1732  1 rt2800lib\n\n\n\n\nIn my setup, the WiPi adapter appears as the wlan1 interface.\n\n\n$ iwconfig\n...\nwlan1     IEEE 802.11bgn  ESSID:off/any\n          Mode:Managed  Access Point: Not-Associated   Tx-Power=20 dBm\n          Retry short limit:7   RTS thr:off   Fragment thr:off\n          Power Management:off\n\n\n\n\nCreating a wireless mesh network\n\n\nAs long as there is kernel support for the WLAN adapter, and the adapter supports\n'mesh' mode, creating a wireless mesh is fairly straightforward. It involves the\nfollowing steps.\n\n\n\n\nDefining a mesh interface name (mesh0 in the example below) and setting a \nmesh_idi\n.\n   The mesh identifier has a similar purpose to the SSID in a \"normal\" WLAN.\n\n\nSetting the channel. The WiPi adapter only supports the 2.4 GHz band and after doing\n   a site survey I decided to use channel 4.\n\n\nShutting down the wlanX interface and bringing up the mesh0 interface instead.\n\n\nAssigning an IP address.\n\n\n\n\n$ sudo iw dev wlan1 interface add mesh0 type mp mesh_id MYMESHID\n$ sudo iw dev mesh0 set channel 4\n$ sudo ifconfig wlan1 down\n$ sudo ifconfig mesh0 up\n$ sudo ip addr add 10.1.100.10/24 dev mesh0\n\n\n\n\nIn my lab, I created a wireless mesh network as shown below. Let's see whether all\nnodes are visible.\n\n\n\n\npi@yellow$ cat /etc/hosts\n127.0.0.1    localhost yellow\n10.2.1.51    blue-mesh\n10.2.1.52    white-mesh\n10.2.1.53    yellow-mesh\n10.2.1.54    red-mesh\n\npi@yellow$ fping white-mesh red-mesh yellow-mesh blue-mesh\nwhite-mesh is alive\nred-mesh is alive\nyellow-mesh is alive\nblue-mesh is alive\n\n\n\n\nThere are a few commands that display status information about the mesh. The \nstation\ndump\n command displays all neighbouring mesh nodes.\n\n\npi@yellow$ sudo iw dev mesh0 station dump | grep Station\nStation 40:a5:ef:0f:41:ef (on mesh0)\nStation 40:a5:ef:0f:4b:e3 (on mesh0)\n\n\n\n\nThe output of the \nmpath dump\n command shows the current HWMP routing table.\nNote how node 40:a5:ef:0f:46:df is reached via 40:a5:ef:0f:41:ef as it did not show\nas a neighbour node in station dump.\n\n\npi@yellow$ sudo iw dev mesh0 mpath dump\nDEST ADDR         NEXT HOP          IFACE    SN      METRIC  QLEN    EXPTIME         DTIM    DRET    FLAGS\n40:a5:ef:0f:4b:e3 40:a5:ef:0f:4b:e3 mesh0    2       8769    0       0       0       0       0x14\n40:a5:ef:0f:41:ef 40:a5:ef:0f:41:ef mesh0    5       8577    0       0       100     0       0x14\n40:a5:ef:0f:46:df 40:a5:ef:0f:41:ef mesh0    11      18786   0       0       200     1       0x4\n\n\n\n\nBecause bitrate most links have a fairly weak signal, the bitrate is slow. This is reflected in the approximately 500 Kbits/sec bandwidth reported by iperf.\n\n\npi@yellow$ sudo iw dev mesh0 station dump | grep bitrate\n     tx bitrate:     1.0 MBit/s\n     rx bitrate:     1.0 MBit/s\n     tx bitrate:     1.0 MBit/s\n     rx bitrate:     1.0 MBit/s\n\n\n\n\nSecurity\n\n\nNote Unfortunately this currently does not work with the rt2800 driver (https://github.com/cozybit/authsae/issues/34).\n\n\nCurrently the released version of wpa_supplicant does not support mesh mode. 802.11s\nrequires the \"Simultaneous Authentication of Equals (SAE)\" protocol with is implemented\nin the (https://github.com/cozybit/authsae) project. Unfortunately this package must\nbe installed manually and has a few dependencies.\n\n\n$ sudo apt-get install cmake libssl-dev libconfig-dev libnl-3-dev libnl-genl-3-dev\n$ git clone https://github.com/cozybit/authsae\n$ cd authsae\n$ make\n$ sudo make install\n$ ls /usr/local/etc/authsae.cfg /usr/local/bin/meshd* /usr/local/bin/mon\n/usr/local/bin/meshd\n/usr/local/bin/meshd-nl80211\n/usr/local/bin/mon\n/usr/local/etc/authsae.cfg\n\n\n\n\nThe README explains the different settings in /usr/local/etc/authsae.cfg. Once\nconfigured, start meshd-nl80211 as follows:\n\n\n$ sudo meshd-nl80211 -c /usr/local/etc/authsae.cfg -o /var/log/meshd.log -B\n\n\n\n\nRouting between wireless mesh and LAN\n\n\nA wireless mesh node that connects to a non-mesh network is called a Mesh Point\nPortal (MPP). Most documents describe how a Mesh Point Portal is used to bridge\nthe mesh and the non-mesh networks. I am going to describe this in the next section.\nFirst I explain how one can make the Mesh Point Portal a router connecting both\nnetworks.\n\n\n\n\nNodes yellow and white are both MPP with a VRRP address of 10.2.1.1 \"floating\"\n  between them on the mesh network.\n\n\nNodes yellow and white run a dynamic routing protocol on the non-mesh network\n  (RIPv2 in the example below) to learn routes from other routers.\n\n\nNodes red and blue use 10.2.1.1 as the default gateway.\n\n\n\n\n\n\nConfigure VRRP on nodes yellow and white\n\n\npi@yellow$ sudo apt-get install keepalived\n\npi@yellow$ sudo vi /etc/keepalived/keepalived.conf\nvrrp_instance VI_1 {\n    state MASTER\n    interface mesh0\n    virtual_router_id 100\n    priority 150\n    advert_int 1\n    authentication {\n        auth_type PASS\n        auth_pass mypasswd\n    }\n    virtual_ipaddress {\n        10.2.1.1\n    }\n}\n\n\n\n\nI decided to start keepalived from the command line. After a few seconds the mesh0 interface will have been assigned the 10.2.1.1 address.\n\n\npi@yellow$ sudo systemctl stop keepalived\n\npi@yellow$ sudo keepalived -f /etc/keepalived/keepalived.conf --vrrp\n\npi@yellow$ ip add li mesh0\n5: mesh0: \nBROADCAST,MULTICAST,UP,LOWER_UP\n mtu 1500 qdisc mq state UP group default qlen 1000\n    link/ether 40:a5:ef:0f:54:5a brd ff:ff:ff:ff:ff:ff\n    inet 10.2.1.53/24 scope global mesh0\n       valid_lft forever preferred_lft forever\n    inet 10.2.1.1/32 scope global mesh0\n       valid_lft forever preferred_lft forever\n\n\n\n\nThe same steps must be performed on node white, with the only difference that the\npriority setting in the configuration file must be different.\n\n\nConfigure dynamic routing on nodes yellow and white\n\n\nFor the purpose of simplicity I'll be configuring RIPv2 as this is the only protocol my\n(consumer grade) Internet Router supports.\n\n\n\n\nEnable IPv4 forwarding.\n\n\nCreate a minimal /etc/quagga/zebra.conf. Nothing will work without this file!\n\n\nConfigure RIPv2 in /etc/quagga/ripd.conf.\n\n\n\n\npi@yellow$ sudo sysctl net.ipv4.ip_forward=1    # enable forwarding\npi@yellow$ sudo apt-get install quagga\npi@yellow$ sudo vi /etc/quagga/daemons\nzebra=yes\n...\nripd=yes\n\npi@yellow$ sudo vi /etc/quagga/zebra.conf\nhostname yellow\n\npi@yellow$ sudo vi /etc/quagga/ripd.conf\nrouter rip\n  network eth0\n  redistribute connected\n\npi@yellow$ sudo systemctl start quagga\n\n\n\n\nConfigure the default gateway on red and blue\n\n\nThis step is straightforward, e.g.\n\n\npi@blue$ sudo route add -net default gw 10.2.1.1\npi@blue$ route -n\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.2.1.1        0.0.0.0         UG    0      0        0 mesh0\n10.2.1.0        0.0.0.0         255.255.255.0   U     0      0        0 mesh0\n\n\n\n\nNow I can ran a full traceroute to the Internet.\n\n\npi@blue$ sudo traceroute -I 150.101.213.146\ntraceroute to 150.101.213.146 (150.101.213.146), 30 hops max, 60 byte packets\n 1  yellow-mesh      3.668 ms   3.480 ms   3.465 ms\n 2  10.1.1.1         3.430 ms   3.367 ms   3.453 ms\n 3  150.101.32.128  14.801 ms  16.476 ms  17.640 ms\n 4  150.101.35.165  18.812 ms  24.582 ms  24.557 ms\n 5  150.101.40.134  24.444 ms  20.036 ms  19.048 ms\n 6  150.101.213.146 16.619 ms  14.815 ms  14.666 ms\n\n\n\n\nInitially the packets will be routed via yellow as it currently holds the VRRP\naddress for the default gateway. If node yellow becomes unavailable, the VRRP\naddress will move to node white.\n\n\nThe main disadvantage of a routed solution is that the mesh nodes will send all\nnon-local traffic to the Portal that is currently the default gateway.\nIt is not possible to load-balance between multiple portals. In large mesh\ntopologies this may be a major disadvantage.\n\n\nBridging the wireless mesh and the LAN\n\n\nThe alternative to routing between a mesh and a non-mesh network is bridging\nthem.\n\n\n\n\nCreate a bridge with the non-mesh and mesh interface.\n  Disable Spanning Tree on this bridge.\n\n\nConfigure the Mesh Gateways to send HWMP gate announcements.\n\n\n\n\n\n\n$ TODO\n\n\n\n\nLinks\n\n\n802.11s\n\n\nThe following links were useful sources of information.\n\n\n\n\n802.11s Mesh Networking\n\n\nIEEE 802.11s Tutorial\n\n\nOpenWRT 802.11s based wireless mesh network\n\n\n\n\nOther Wireless Mesh Protocols\n\n\nApart from 802.11s there are a couple of alternative protocols implementing wireless\nmesh networks.\n\n\n\n\nMobile Mesh Networks with the Raspberry Pi\n\n\nEnabling mesh (ad-hoc) network on multiple Raspberry Pi\u2019s\n\n\nHeterogeneous Wireless Mesh Network Technology Evaluation for Space Proximity and Surface Applications", 
            "title": "802.11s Wireless Mesh Network"
        }, 
        {
            "location": "/80211s_wireless_mesh/#80211s-wireless-mesh-network", 
            "text": "This document is work in progress", 
            "title": "802.11s Wireless Mesh Network"
        }, 
        {
            "location": "/80211s_wireless_mesh/#overview", 
            "text": "Originally the 802.11 WiFi standards defined two modes of operation, \n\"ad-hoc\" and \"infrastructure\".\nThe 802.11s amendment introduces another mode: mesh networks.\nThe distinguishing feature of mesh networks is that each node is able to forward\n802.11 frames to other nodes, potentially extending the range of the overall\nnetwork. This is different from \"infrastructure mode\" where all nodes communicate\nvia a central Access Point.   Nodes in a wireless mesh network may be mobile and it is the task of a (OSI layer 2)\nmesh routing protocols to continuously determine the optimal path between any two\nmesh nodes. The 802.11s document mandates the  Hybrid Wireless Mesh Protocol (HWMP) \nas the standard routing protocol but others can be implemented.  In this document I am going to describe how to configure a small wireless mesh network\nbased on the open80211s implementation on a few RaspberryPi.", 
            "title": "Overview"
        }, 
        {
            "location": "/80211s_wireless_mesh/#hardware-software", 
            "text": "The following hardware and software was used for this experiment.   Multiple RaspberryPi (various models) serving as Wireless Mesh Nodes and clients.  element14 WIPI WLAN USB Module \n  for Raspberry Pi as it supports mesh mode.", 
            "title": "Hardware &amp; Software"
        }, 
        {
            "location": "/80211s_wireless_mesh/#configuring-open80211s", 
            "text": "In this section I am going to focus on how to get an 802.11s mesh network up and\nrunning using the  open80211s \nsoftware. open80211s is an open-source implementation\nof the recently ratified IEEE 802.11s wireless mesh standard. The project's Wiki\npage provides a lot of background information about 802.11s and the steps summarised\nin this document are based on the Wiki page.  The 2016-05-27-raspbian-jessie-lite.img version of Raspbian serves as the base for\nmy experiments with the open80211s software. It is good practice to update the\ndistribution first.  $ sudo apt-get update\n$ sudo apt-get dist-upgrade\n$ reboot\n\n$ uname -a\nLinux yellow 4.4.13+ #894 Mon Jun 13 12:43:26 BST 2016 armv6l GNU/Linux", 
            "title": "Configuring open80211s"
        }, 
        {
            "location": "/80211s_wireless_mesh/#kernel-support", 
            "text": "The WiPi USB WLAN adapter uses a RT5370 chip which is supported through the  RT2800 driver . Most importantly is uses the\nmac80211 module which is a pre-requisite for open80211s to work.  $ lsusb\nBus 001 Device 005: ID 148f:5370 Ralink Technology, Corp. RT5370 Wireless Adapter\n...\n\n$ sudo modprobe rt2800usb\n\n$ lsmod | grep 2800\nrt2800usb              18877  0\nrt2800lib              82155  1 rt2800usb\nrt2x00usb              12680  1 rt2800usb\nrt2x00lib              48998  3 rt2x00usb,rt2800lib,rt2800usb\nmac80211              608549  3 rt2x00lib,rt2x00usb,rt2800lib\ncrc_ccitt               1732  1 rt2800lib  In my setup, the WiPi adapter appears as the wlan1 interface.  $ iwconfig\n...\nwlan1     IEEE 802.11bgn  ESSID:off/any\n          Mode:Managed  Access Point: Not-Associated   Tx-Power=20 dBm\n          Retry short limit:7   RTS thr:off   Fragment thr:off\n          Power Management:off", 
            "title": "Kernel support"
        }, 
        {
            "location": "/80211s_wireless_mesh/#creating-a-wireless-mesh-network", 
            "text": "As long as there is kernel support for the WLAN adapter, and the adapter supports\n'mesh' mode, creating a wireless mesh is fairly straightforward. It involves the\nfollowing steps.   Defining a mesh interface name (mesh0 in the example below) and setting a  mesh_idi .\n   The mesh identifier has a similar purpose to the SSID in a \"normal\" WLAN.  Setting the channel. The WiPi adapter only supports the 2.4 GHz band and after doing\n   a site survey I decided to use channel 4.  Shutting down the wlanX interface and bringing up the mesh0 interface instead.  Assigning an IP address.   $ sudo iw dev wlan1 interface add mesh0 type mp mesh_id MYMESHID\n$ sudo iw dev mesh0 set channel 4\n$ sudo ifconfig wlan1 down\n$ sudo ifconfig mesh0 up\n$ sudo ip addr add 10.1.100.10/24 dev mesh0  In my lab, I created a wireless mesh network as shown below. Let's see whether all\nnodes are visible.   pi@yellow$ cat /etc/hosts\n127.0.0.1    localhost yellow\n10.2.1.51    blue-mesh\n10.2.1.52    white-mesh\n10.2.1.53    yellow-mesh\n10.2.1.54    red-mesh\n\npi@yellow$ fping white-mesh red-mesh yellow-mesh blue-mesh\nwhite-mesh is alive\nred-mesh is alive\nyellow-mesh is alive\nblue-mesh is alive  There are a few commands that display status information about the mesh. The  station\ndump  command displays all neighbouring mesh nodes.  pi@yellow$ sudo iw dev mesh0 station dump | grep Station\nStation 40:a5:ef:0f:41:ef (on mesh0)\nStation 40:a5:ef:0f:4b:e3 (on mesh0)  The output of the  mpath dump  command shows the current HWMP routing table.\nNote how node 40:a5:ef:0f:46:df is reached via 40:a5:ef:0f:41:ef as it did not show\nas a neighbour node in station dump.  pi@yellow$ sudo iw dev mesh0 mpath dump\nDEST ADDR         NEXT HOP          IFACE    SN      METRIC  QLEN    EXPTIME         DTIM    DRET    FLAGS\n40:a5:ef:0f:4b:e3 40:a5:ef:0f:4b:e3 mesh0    2       8769    0       0       0       0       0x14\n40:a5:ef:0f:41:ef 40:a5:ef:0f:41:ef mesh0    5       8577    0       0       100     0       0x14\n40:a5:ef:0f:46:df 40:a5:ef:0f:41:ef mesh0    11      18786   0       0       200     1       0x4  Because bitrate most links have a fairly weak signal, the bitrate is slow. This is reflected in the approximately 500 Kbits/sec bandwidth reported by iperf.  pi@yellow$ sudo iw dev mesh0 station dump | grep bitrate\n     tx bitrate:     1.0 MBit/s\n     rx bitrate:     1.0 MBit/s\n     tx bitrate:     1.0 MBit/s\n     rx bitrate:     1.0 MBit/s", 
            "title": "Creating a wireless mesh network"
        }, 
        {
            "location": "/80211s_wireless_mesh/#security", 
            "text": "Note Unfortunately this currently does not work with the rt2800 driver (https://github.com/cozybit/authsae/issues/34).  Currently the released version of wpa_supplicant does not support mesh mode. 802.11s\nrequires the \"Simultaneous Authentication of Equals (SAE)\" protocol with is implemented\nin the (https://github.com/cozybit/authsae) project. Unfortunately this package must\nbe installed manually and has a few dependencies.  $ sudo apt-get install cmake libssl-dev libconfig-dev libnl-3-dev libnl-genl-3-dev\n$ git clone https://github.com/cozybit/authsae\n$ cd authsae\n$ make\n$ sudo make install\n$ ls /usr/local/etc/authsae.cfg /usr/local/bin/meshd* /usr/local/bin/mon\n/usr/local/bin/meshd\n/usr/local/bin/meshd-nl80211\n/usr/local/bin/mon\n/usr/local/etc/authsae.cfg  The README explains the different settings in /usr/local/etc/authsae.cfg. Once\nconfigured, start meshd-nl80211 as follows:  $ sudo meshd-nl80211 -c /usr/local/etc/authsae.cfg -o /var/log/meshd.log -B", 
            "title": "Security"
        }, 
        {
            "location": "/80211s_wireless_mesh/#routing-between-wireless-mesh-and-lan", 
            "text": "A wireless mesh node that connects to a non-mesh network is called a Mesh Point\nPortal (MPP). Most documents describe how a Mesh Point Portal is used to bridge\nthe mesh and the non-mesh networks. I am going to describe this in the next section.\nFirst I explain how one can make the Mesh Point Portal a router connecting both\nnetworks.   Nodes yellow and white are both MPP with a VRRP address of 10.2.1.1 \"floating\"\n  between them on the mesh network.  Nodes yellow and white run a dynamic routing protocol on the non-mesh network\n  (RIPv2 in the example below) to learn routes from other routers.  Nodes red and blue use 10.2.1.1 as the default gateway.", 
            "title": "Routing between wireless mesh and LAN"
        }, 
        {
            "location": "/80211s_wireless_mesh/#configure-vrrp-on-nodes-yellow-and-white", 
            "text": "pi@yellow$ sudo apt-get install keepalived\n\npi@yellow$ sudo vi /etc/keepalived/keepalived.conf\nvrrp_instance VI_1 {\n    state MASTER\n    interface mesh0\n    virtual_router_id 100\n    priority 150\n    advert_int 1\n    authentication {\n        auth_type PASS\n        auth_pass mypasswd\n    }\n    virtual_ipaddress {\n        10.2.1.1\n    }\n}  I decided to start keepalived from the command line. After a few seconds the mesh0 interface will have been assigned the 10.2.1.1 address.  pi@yellow$ sudo systemctl stop keepalived\n\npi@yellow$ sudo keepalived -f /etc/keepalived/keepalived.conf --vrrp\n\npi@yellow$ ip add li mesh0\n5: mesh0:  BROADCAST,MULTICAST,UP,LOWER_UP  mtu 1500 qdisc mq state UP group default qlen 1000\n    link/ether 40:a5:ef:0f:54:5a brd ff:ff:ff:ff:ff:ff\n    inet 10.2.1.53/24 scope global mesh0\n       valid_lft forever preferred_lft forever\n    inet 10.2.1.1/32 scope global mesh0\n       valid_lft forever preferred_lft forever  The same steps must be performed on node white, with the only difference that the\npriority setting in the configuration file must be different.", 
            "title": "Configure VRRP on nodes yellow and white"
        }, 
        {
            "location": "/80211s_wireless_mesh/#configure-dynamic-routing-on-nodes-yellow-and-white", 
            "text": "For the purpose of simplicity I'll be configuring RIPv2 as this is the only protocol my\n(consumer grade) Internet Router supports.   Enable IPv4 forwarding.  Create a minimal /etc/quagga/zebra.conf. Nothing will work without this file!  Configure RIPv2 in /etc/quagga/ripd.conf.   pi@yellow$ sudo sysctl net.ipv4.ip_forward=1    # enable forwarding\npi@yellow$ sudo apt-get install quagga\npi@yellow$ sudo vi /etc/quagga/daemons\nzebra=yes\n...\nripd=yes\n\npi@yellow$ sudo vi /etc/quagga/zebra.conf\nhostname yellow\n\npi@yellow$ sudo vi /etc/quagga/ripd.conf\nrouter rip\n  network eth0\n  redistribute connected\n\npi@yellow$ sudo systemctl start quagga", 
            "title": "Configure dynamic routing on nodes yellow and white"
        }, 
        {
            "location": "/80211s_wireless_mesh/#configure-the-default-gateway-on-red-and-blue", 
            "text": "This step is straightforward, e.g.  pi@blue$ sudo route add -net default gw 10.2.1.1\npi@blue$ route -n\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.2.1.1        0.0.0.0         UG    0      0        0 mesh0\n10.2.1.0        0.0.0.0         255.255.255.0   U     0      0        0 mesh0  Now I can ran a full traceroute to the Internet.  pi@blue$ sudo traceroute -I 150.101.213.146\ntraceroute to 150.101.213.146 (150.101.213.146), 30 hops max, 60 byte packets\n 1  yellow-mesh      3.668 ms   3.480 ms   3.465 ms\n 2  10.1.1.1         3.430 ms   3.367 ms   3.453 ms\n 3  150.101.32.128  14.801 ms  16.476 ms  17.640 ms\n 4  150.101.35.165  18.812 ms  24.582 ms  24.557 ms\n 5  150.101.40.134  24.444 ms  20.036 ms  19.048 ms\n 6  150.101.213.146 16.619 ms  14.815 ms  14.666 ms  Initially the packets will be routed via yellow as it currently holds the VRRP\naddress for the default gateway. If node yellow becomes unavailable, the VRRP\naddress will move to node white.  The main disadvantage of a routed solution is that the mesh nodes will send all\nnon-local traffic to the Portal that is currently the default gateway.\nIt is not possible to load-balance between multiple portals. In large mesh\ntopologies this may be a major disadvantage.", 
            "title": "Configure the default gateway on red and blue"
        }, 
        {
            "location": "/80211s_wireless_mesh/#bridging-the-wireless-mesh-and-the-lan", 
            "text": "The alternative to routing between a mesh and a non-mesh network is bridging\nthem.   Create a bridge with the non-mesh and mesh interface.\n  Disable Spanning Tree on this bridge.  Configure the Mesh Gateways to send HWMP gate announcements.    $ TODO", 
            "title": "Bridging the wireless mesh and the LAN"
        }, 
        {
            "location": "/80211s_wireless_mesh/#links", 
            "text": "", 
            "title": "Links"
        }, 
        {
            "location": "/80211s_wireless_mesh/#80211s", 
            "text": "The following links were useful sources of information.   802.11s Mesh Networking  IEEE 802.11s Tutorial  OpenWRT 802.11s based wireless mesh network", 
            "title": "802.11s"
        }, 
        {
            "location": "/80211s_wireless_mesh/#other-wireless-mesh-protocols", 
            "text": "Apart from 802.11s there are a couple of alternative protocols implementing wireless\nmesh networks.   Mobile Mesh Networks with the Raspberry Pi  Enabling mesh (ad-hoc) network on multiple Raspberry Pi\u2019s  Heterogeneous Wireless Mesh Network Technology Evaluation for Space Proximity and Surface Applications", 
            "title": "Other Wireless Mesh Protocols"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/", 
            "text": "Pycom SiPy and Sigfox\n\n\nSigfox\n\n\nOver the last few days I started experimenting with the \nSigfox\n\nLow Power Wide Area Network (LPWAN). As a LPWAN, Sigfox is aimed at the\nInternet-of-Things (IoT) and trades throughput for long distance communications and\nlong battery life.\n\n\nSigfox operates in the \nISM radio band\n.\nBecause of ISM band regulations the transmission duty cycle is limited to 1% equalling\nat most 140 messages per day per device. Most applications will probably send a lot \nfewer messages per day in order to save power.\n\n\nThe payload of Sigfox message is 96 bits\n(12 bytes) for the uplink and 64 bits (8 bytes) for downlink messages but a\ndownlink message will only be send if a device polls for one.\n\n\nThe Sigfox protocol does not define any media access mechanism. A device simply\ntransmits each message three times on different frequencies, expecting that\nat least one basestation withing range (which can be\ntens of kilometres away) will receive it successfully.\nThe basestation will then forward the message to a Sigfox backend server for\nprocessing.\n\n\nPycom SiPy\n\n\nAs hardware I decided to buy a \nPycom SiPy\n \nmicro-controller for the simple reason that it can be programmed with\n\nMicroPython\n. This makes it an ideal platform for\nquick proto-typing. I added the\n\nPycom Expansion Board\n and \nthe Antenna Kit.\n\n\nPycom also offer other interesting expansion boards but for\nsimply familiarising yourself with the SigFox service those are not needed.\n\n\nI split this article into several parts.\n\n\n\n\nIntroduction to Pycom SiPy\n\n\nSending a Sigfox message\n\n\nThe Sigfox backend service\n\n\nSigfox downlink messages\n\n\nBuilding a custom firmware for the SiPy\n\n\nEncrypting Sigfox messages\n\n\nAn example GPS tracker application", 
            "title": "Pycom SiPy and Sigfox"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/#pycom-sipy-and-sigfox", 
            "text": "", 
            "title": "Pycom SiPy and Sigfox"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/#sigfox", 
            "text": "Over the last few days I started experimenting with the  Sigfox \nLow Power Wide Area Network (LPWAN). As a LPWAN, Sigfox is aimed at the\nInternet-of-Things (IoT) and trades throughput for long distance communications and\nlong battery life.  Sigfox operates in the  ISM radio band .\nBecause of ISM band regulations the transmission duty cycle is limited to 1% equalling\nat most 140 messages per day per device. Most applications will probably send a lot \nfewer messages per day in order to save power.  The payload of Sigfox message is 96 bits\n(12 bytes) for the uplink and 64 bits (8 bytes) for downlink messages but a\ndownlink message will only be send if a device polls for one.  The Sigfox protocol does not define any media access mechanism. A device simply\ntransmits each message three times on different frequencies, expecting that\nat least one basestation withing range (which can be\ntens of kilometres away) will receive it successfully.\nThe basestation will then forward the message to a Sigfox backend server for\nprocessing.", 
            "title": "Sigfox"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/#pycom-sipy", 
            "text": "As hardware I decided to buy a  Pycom SiPy  \nmicro-controller for the simple reason that it can be programmed with MicroPython . This makes it an ideal platform for\nquick proto-typing. I added the Pycom Expansion Board  and \nthe Antenna Kit.  Pycom also offer other interesting expansion boards but for\nsimply familiarising yourself with the SigFox service those are not needed.  I split this article into several parts.   Introduction to Pycom SiPy  Sending a Sigfox message  The Sigfox backend service  Sigfox downlink messages  Building a custom firmware for the SiPy  Encrypting Sigfox messages  An example GPS tracker application", 
            "title": "Pycom SiPy"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/encrypting_sigfox_messages/", 
            "text": "Encrypting Sigfox messages\n\n\nAES and other ciphers\n\n\nEncrypting Sigfox messages poses some unique challenges.\n\n\n\n\nBlock ciphers algorithms like \nAES\n \n  normally operate on data of fixed length. In case of AES this is 128 bits which \n  is larger than the 96 bits payload of Sigfox.\n\n\nBlock Ciphers can be operated in stream mode but require an \"initialisation vector\"\n  (IV) which must also be transmitted. The IV, at least in the case of AES, must\n  be of the same size as the cipher's block size, i.e. 128 bits, it again exceeds the\n  payload size of a Sigfox message. The only possible work-around is to transmit\n  the encrypted data in two Sigfox messages which is inefficient.\n\n\n\n\nThere is a whole new research domain of Lightweigth Cryptography for the\nInternet of Things. The \neSTREAM\n project\nresulted in a suite of ciphers aimed at resource constrained environments.\n\n\nThe Speck Cipher\n\n\nA very interesting candidate is the\n\nSpeck cipher\n. What makes this cipher\nso appealing to Sigfox is that it offers small and variable length block sizes\nof 32, 48, 64 and 96 bits. Calvin McCoy implemented\n\nSpeck in Python\n which I used\nfor encrypting Sigfox messages on the Pycom Sipy. The example below encodes and encrypts\nGPS latitude and longitude as two 32 bit floats.\n\n\nimport struct\nimport speck    # https://github.com/inmcm/Simon_Speck_Ciphers/tree/master/Python\n\nlatitude = -37.12345\nlongitude = 145.12345\npacked = struct.pack(\nff\n, latitude, longitude)    # 64 bits block\n\ncipherkey = 'notverysecurekey'                      # 128 bits key\ncipher = speck.SpeckCipher(cipherkey, key_size=128, block_size=64)\nencrypted = cipher.encrypt(packed)\n\n\n\n\nOne concern of the above approach may be that two messages will be encrypted\nidentically if they contain the same latitude and longitude. Adding 32 random\nbits will remedy this concern.\n\n\nfrom crypto import getrandbits\npacked = struct.pack(\nffI\n, latitude, longitude, getrandbits(32))\ncipher = speck.SpeckCipher(cipherkey, key_size=128, block_size=96)\nencrypted = cipher.encrypt(packed)\n\n\n\n\nThere is a final note to encrypting Sigfox messages. The Sigfox backend callback\nwon't be able to interpret the - now encrypted - message payload anymore! The\n\n{data}\n field can only be forwarded unchanged and decrypted by some other\nmechanism, e.g. a custom AWS Lambda function.", 
            "title": "Pycom SiPy and Sigfox Encrypting Sigfox messages"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/encrypting_sigfox_messages/#encrypting-sigfox-messages", 
            "text": "", 
            "title": "Encrypting Sigfox messages"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/encrypting_sigfox_messages/#aes-and-other-ciphers", 
            "text": "Encrypting Sigfox messages poses some unique challenges.   Block ciphers algorithms like  AES  \n  normally operate on data of fixed length. In case of AES this is 128 bits which \n  is larger than the 96 bits payload of Sigfox.  Block Ciphers can be operated in stream mode but require an \"initialisation vector\"\n  (IV) which must also be transmitted. The IV, at least in the case of AES, must\n  be of the same size as the cipher's block size, i.e. 128 bits, it again exceeds the\n  payload size of a Sigfox message. The only possible work-around is to transmit\n  the encrypted data in two Sigfox messages which is inefficient.   There is a whole new research domain of Lightweigth Cryptography for the\nInternet of Things. The  eSTREAM  project\nresulted in a suite of ciphers aimed at resource constrained environments.", 
            "title": "AES and other ciphers"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/encrypting_sigfox_messages/#the-speck-cipher", 
            "text": "A very interesting candidate is the Speck cipher . What makes this cipher\nso appealing to Sigfox is that it offers small and variable length block sizes\nof 32, 48, 64 and 96 bits. Calvin McCoy implemented Speck in Python  which I used\nfor encrypting Sigfox messages on the Pycom Sipy. The example below encodes and encrypts\nGPS latitude and longitude as two 32 bit floats.  import struct\nimport speck    # https://github.com/inmcm/Simon_Speck_Ciphers/tree/master/Python\n\nlatitude = -37.12345\nlongitude = 145.12345\npacked = struct.pack( ff , latitude, longitude)    # 64 bits block\n\ncipherkey = 'notverysecurekey'                      # 128 bits key\ncipher = speck.SpeckCipher(cipherkey, key_size=128, block_size=64)\nencrypted = cipher.encrypt(packed)  One concern of the above approach may be that two messages will be encrypted\nidentically if they contain the same latitude and longitude. Adding 32 random\nbits will remedy this concern.  from crypto import getrandbits\npacked = struct.pack( ffI , latitude, longitude, getrandbits(32))\ncipher = speck.SpeckCipher(cipherkey, key_size=128, block_size=96)\nencrypted = cipher.encrypt(packed)  There is a final note to encrypting Sigfox messages. The Sigfox backend callback\nwon't be able to interpret the - now encrypted - message payload anymore! The {data}  field can only be forwarded unchanged and decrypted by some other\nmechanism, e.g. a custom AWS Lambda function.", 
            "title": "The Speck Cipher"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/firmware_upgrade/", 
            "text": "Building the SiPy Firmware\n\n\nThe first question you have to ask yourself is, why would you go through the\ntrouble of building a custom firmware. I've done this often enough for other devices\nand it isn't always the easiest of exercises. So why bother doing it? In case of the\nPycom SiPy the answer lies in hardware quirk. Any Python modules that are pre-compiled\n and stored in flash memory don't require any RAM when imported. The SiPy\nhas very little RAM and it is easy to run out of memory when importing larger\nPython modules. This happened to me when I tried to import the\n\nbitstring\n module from SD card.\n\n\nPreparing the build environment\n\n\nFirst one has to install a few required software packages. The example below applies\nto Fedora so if you run a different distribution the package names may be different.\n\n\n$ sudo yum install git wget make ncurses-devel flex bison gperf python pyserial\n\n\n\n\nNext download and extract the cross-compiler. I keep everything under the\n\n$HOME/Projects/IoT/Pycom/ESP\n path but that's just my personal setup.\n\n\n$ cd /tmp\n$ wget https://dl.espressif.com/dl/xtensa-esp32-elf-linux64-1.22.0-61-gab8375a-5.2.0.tar.gz\n$ cd $HOME/Projects/IoT/Pycom/ESP\n$ tar xvfz /tmp/xtensa-esp32-elf-linux64-1.22.0-61-gab8375a-5.2.0.tar.gz\n\n\n\n\nNext clone the necessary Pycom Git repositories. Pycom  maintain their\nown fork of MicroPython.\n\n\n$ cd $HOME/Projects/IoT/Pycom/ESP\n$ git clone --recursive https://github.com/pycom/pycom-esp-idf.git\n$ git clone --recursive https://github.com/pycom/pycom-micropython-sigfox.git\n\n\n\n\nCustomising the build\n\n\nNext edit the key C header file and add the \n#define...\n line as show below. This\nenables the feature to load pre-compiled \n*.mpy\n code. By default this is \ndsiabled. \n*.mpy\n files are MicroPython's equivalent to \n*.pyc\n files.\n\n\n$ cd $HOME/Projects/IoT/Pycom/ESP/pycom-micropython-sigfox/esp32/\n$ vi mpconfigport.h\n#define MICROPY_PERSISTENT_CODE_LOAD (1)\n\n\n\n\nIt is important to amend the \nPATH\n and set \nIDF_PATH\n before proceeding.\n\n\n$ export PATH=$PATH:$HOME/Projects/IoT/Pycom/ESP/xtensa-esp32-elf/bin\n$ export IDF_PATH=$HOME/Projects/IoT/Pycom/ESP/pycom-esp-idf\n\n\n\n\nNow build the MicroPython pre-compiler.\n\n\n$ cd $HOME/Projects/IoT/Pycom/ESP/pycom-micropython-sigfox/mpy-cross\n$ make clean\n$ make all\n\n\n\n\nAdding Python modules\n\n\nThis is the moment to add any Python modules that are meant to be built into\nthe firmware. Simply copy them to the \nfrozen/\n folder. That's all. The \nfrozen/\n\nfolder already contains a \n_boot.py\n file which is \nnot\n the \n/flash/boot.py\n\nscript. Don't remove \n_boot.py\n as without it the SiPy won't start.\n\n\n$ cd $HOME/Projects/IoT/Pycom/ESP/pycom-micropython-sigfox/esp32/\n$ ls frozen/\n_boot.py\n\n\n\n\nBuilding the firmware\n\n\nEventually the firmware and bootloader can be build.\n\n\n$ cd $HOME/Projects/IoT/Pycom/ESP/pycom-micropython-sigfox/esp32/\n$ make BOARD=SIPY TARGET=boot V=1 clean\n$ make BOARD=SIPY TARGET=boot V=1\n$ make BOARD=SIPY TARGET=app V=1\n\n\n\n\nUploading the firmware\n\n\nThe \nMakefile\n also allows to upload the new firmware to the SiPy.\nConnect pin P2 (G23 on the expansion board) to GND with a jumper wire \nand press the reset\nbutton. The adjust the permissions on the \n/dev/ttyUSBx\n device and\nupload the firmware. This takes only a few seconds.\n\n\n$ sudo chmod a+rw /dev/ttyUSB0\n$ make BOARD=SIPY flash\n\n\n\n\nRemove the jumper wire and power-cycle the SiPy. The SiPy should have booted\ninto the new firmware.\n\n\n os.uname()\n(sysname='SiPy', nodename='SiPy', release='1.7.3.b2', \n version='41c42b2-dirty on 2017-06-23', machine='SiPy with ESP32', sigfox='1.0.1')\n\n\n\n\nIf the firmware upload failed the SiPy will show a bright red LED. Don't panic,\nand follow \n\nthese instructions\n.\n\n\nLinks\n\n\n\n\nStandard Setup of ESP-IDF Toolchain for Linux\n\n\nPycom fork of MicroPython source\n - see \nesp32\n folder for Pycom SiPy.", 
            "title": "Pycom SiPy and Sigfox Firmware Upgrade"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/firmware_upgrade/#building-the-sipy-firmware", 
            "text": "The first question you have to ask yourself is, why would you go through the\ntrouble of building a custom firmware. I've done this often enough for other devices\nand it isn't always the easiest of exercises. So why bother doing it? In case of the\nPycom SiPy the answer lies in hardware quirk. Any Python modules that are pre-compiled\n and stored in flash memory don't require any RAM when imported. The SiPy\nhas very little RAM and it is easy to run out of memory when importing larger\nPython modules. This happened to me when I tried to import the bitstring  module from SD card.", 
            "title": "Building the SiPy Firmware"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/firmware_upgrade/#preparing-the-build-environment", 
            "text": "First one has to install a few required software packages. The example below applies\nto Fedora so if you run a different distribution the package names may be different.  $ sudo yum install git wget make ncurses-devel flex bison gperf python pyserial  Next download and extract the cross-compiler. I keep everything under the $HOME/Projects/IoT/Pycom/ESP  path but that's just my personal setup.  $ cd /tmp\n$ wget https://dl.espressif.com/dl/xtensa-esp32-elf-linux64-1.22.0-61-gab8375a-5.2.0.tar.gz\n$ cd $HOME/Projects/IoT/Pycom/ESP\n$ tar xvfz /tmp/xtensa-esp32-elf-linux64-1.22.0-61-gab8375a-5.2.0.tar.gz  Next clone the necessary Pycom Git repositories. Pycom  maintain their\nown fork of MicroPython.  $ cd $HOME/Projects/IoT/Pycom/ESP\n$ git clone --recursive https://github.com/pycom/pycom-esp-idf.git\n$ git clone --recursive https://github.com/pycom/pycom-micropython-sigfox.git", 
            "title": "Preparing the build environment"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/firmware_upgrade/#customising-the-build", 
            "text": "Next edit the key C header file and add the  #define...  line as show below. This\nenables the feature to load pre-compiled  *.mpy  code. By default this is \ndsiabled.  *.mpy  files are MicroPython's equivalent to  *.pyc  files.  $ cd $HOME/Projects/IoT/Pycom/ESP/pycom-micropython-sigfox/esp32/\n$ vi mpconfigport.h\n#define MICROPY_PERSISTENT_CODE_LOAD (1)  It is important to amend the  PATH  and set  IDF_PATH  before proceeding.  $ export PATH=$PATH:$HOME/Projects/IoT/Pycom/ESP/xtensa-esp32-elf/bin\n$ export IDF_PATH=$HOME/Projects/IoT/Pycom/ESP/pycom-esp-idf  Now build the MicroPython pre-compiler.  $ cd $HOME/Projects/IoT/Pycom/ESP/pycom-micropython-sigfox/mpy-cross\n$ make clean\n$ make all", 
            "title": "Customising the build"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/firmware_upgrade/#adding-python-modules", 
            "text": "This is the moment to add any Python modules that are meant to be built into\nthe firmware. Simply copy them to the  frozen/  folder. That's all. The  frozen/ \nfolder already contains a  _boot.py  file which is  not  the  /flash/boot.py \nscript. Don't remove  _boot.py  as without it the SiPy won't start.  $ cd $HOME/Projects/IoT/Pycom/ESP/pycom-micropython-sigfox/esp32/\n$ ls frozen/\n_boot.py", 
            "title": "Adding Python modules"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/firmware_upgrade/#building-the-firmware", 
            "text": "Eventually the firmware and bootloader can be build.  $ cd $HOME/Projects/IoT/Pycom/ESP/pycom-micropython-sigfox/esp32/\n$ make BOARD=SIPY TARGET=boot V=1 clean\n$ make BOARD=SIPY TARGET=boot V=1\n$ make BOARD=SIPY TARGET=app V=1", 
            "title": "Building the firmware"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/firmware_upgrade/#uploading-the-firmware", 
            "text": "The  Makefile  also allows to upload the new firmware to the SiPy.\nConnect pin P2 (G23 on the expansion board) to GND with a jumper wire \nand press the reset\nbutton. The adjust the permissions on the  /dev/ttyUSBx  device and\nupload the firmware. This takes only a few seconds.  $ sudo chmod a+rw /dev/ttyUSB0\n$ make BOARD=SIPY flash  Remove the jumper wire and power-cycle the SiPy. The SiPy should have booted\ninto the new firmware.   os.uname()\n(sysname='SiPy', nodename='SiPy', release='1.7.3.b2', \n version='41c42b2-dirty on 2017-06-23', machine='SiPy with ESP32', sigfox='1.0.1')  If the firmware upload failed the SiPy will show a bright red LED. Don't panic,\nand follow  these instructions .", 
            "title": "Uploading the firmware"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/firmware_upgrade/#links", 
            "text": "Standard Setup of ESP-IDF Toolchain for Linux  Pycom fork of MicroPython source  - see  esp32  folder for Pycom SiPy.", 
            "title": "Links"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/introduction_to_sipy/", 
            "text": "The Pycom Sipy\n\n\nThe \nPycom SiPy\n is a multi-network (Sigfox, WiFi\nand Bluetooth LE) development platform which is programmable with\n\nMicroPython\n. The SiPy can be fitted into the\n\nExpansion board\n which adds\nUSB power and console access as well as an SD card slot. Pycom also offer\nhardware for LoRaWAN and LTE CAT M1/NB1 networks as well as other expansion\nboards.\n\n\nConnecting to the SiPy\n\n\nThe SiPy can be powered over the Expansion Boards micro-USB port which also\nserves as the serial console.\n\n\n$ dmesg\n[2371388.193802] usb 5-1: new full-speed USB device number 27 using ohci-pci\n[2371388.357021] usb 5-1: New USB device found, idVendor=0403, idProduct=6015\n[2371388.357033] usb 5-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3\n[2371388.357036] usb 5-1: Product: FT230X Basic UART\n[2371388.357039] usb 5-1: Manufacturer: FTDI\n[2371388.357041] usb 5-1: SerialNumber: DO0039D6\n[2371388.363250] ftdi_sio 5-1:1.0: FTDI USB Serial Device converter detected\n[2371388.363449] usb 5-1: Detected FT-X\n[2371388.367270] usb 5-1: FTDI USB Serial Device converter now attached to ttyUSB0\n\n$ cat /etc/minirc.sipy \npu rtscts           No \npu localecho        No\n\n$ sudo minicom -D /dev/ttyUSB0 --noinit sipy\n\n\n\n\nThe console interface actually presents the interactive MicroPython prompt. This is\nreally nice for exploring and prototyping. Check the tutorial and reference sections\nof the \nofficial documentation\n to get started.\n\n\n import os\n\n os.uname()\n(sysname='SiPy', nodename='SiPy', release='1.7.3.b2', version='41c42b2-dirty on 2017-06-26', machine='SiPy with ESP32', sigfox='1.0.1')\n\n\n\n\nAlternatively one can access the SiPy via Telnet but one has to configure the\nWLAN interface first. \n\n\n from network import WLAN\n\n wlan = WLAN(mode=WLAN.STA)\n\n wlan.ifconfig(config='dhcp')\n\n wlan.scan()\n[(ssid='MYSSID', bssid=b'.......', sec=3, channel=12, rssi=-42)]\n\n WLAN_SSID='MYSSID'\n\n WLAN_KEY='MYKEY'\n\n wlan.connect(ssid=WLAN_SSID, auth=(WLAN.WPA2, WLAN_KEY))\n\n wlan.isconnected()\nTrue\n\n wlan.ifconfig()\n('10.1.1.34', '255.255.255.0', '10.1.1.1', '10.1.1.1')\n\n\n\n\n$ telnet 10.1.1.34\nTrying 10.1.1.34...\nConnected to 10.1.1.34.\nEscape character is '^]'.\nMicroPython 41c42b2-dirty on 2017-06-26; SiPy with ESP32\nLogin as: micro\nPassword: python\nLogin succeeded!\nType \nhelp()\n for more information.\n\n\nCTRL-C\ntelnet\n quit\n\n\n\n\nThe SiPy also features a built-in FTP server which is required if one wants to\nupload Python scripts to the device's flash memory.\n\n\n$ ftp 10.1.1.34\nConnected to 10.1.1.34 (10.1.1.34).\n220 Micropython FTP Server\nName (10.1.1.34:mjuenemann): micro\n331 \nPassword:\n230 \nRemote system type is UNIX.\nUsing binary mode to transfer files.\nftp\n ls\n227 (10,1,1,34,7,232)\n150 \ndrw-rw-r--   1 root  root         0 Jan  1  1985 flash\n226 \nftp\n cd flash\n250 \nftp\n ls\n227 (10,1,1,34,7,232)\n150 \n-rw-rw-r--   1 root  root        34 Jan  1  2098 main.py\ndrw-rw-r--   1 root  root         0 Jan  1  2098 sys\ndrw-rw-r--   1 root  root         0 Jan  1  2098 lib\ndrw-rw-r--   1 root  root         0 Jan  1  2098 cert\n-rw-rw-r--   1 root  root        29 Jan  1  2098 boot.py\n226 \nftp\n bye\n\n\n\n\nThe \n/flash/boot.py\n and \n/flash/main.py\n scripts\n\n\nThe \nboot.py\n and \nmain.py\n script implement the application logic of the SiPy.\nThe purpose of the boot script is to set-up the environment for the main script.\nthe boot script is run once after reset.\nThe main script is executed after the boot script and inherits the namespace, i.e.\nany imports or variables defined in \nboot.py\n are available in \nmain.py\n. The\ndefault main script does nothing and it is up to the application developer\nto create and upload a custom \nmain.py\n script. \n\n\nMicroPython on SiPy examples\n\n\nReading from UART\n\n\n from machine import UART\n\n\n uart = UART()\n\n uart.init(baudrate=4800, bits = 8, parity = None, stop = 1, \n              pins = ('P3', 'P4'),     # P3=TX (G21 on Expansion Board), P4=Rx (G11)\n              timeout_chars=10)        # Read timeout in chars/baudrate, if set too low readline() won't work!!!\n\n\n if uart.any():\n...     uart.readline()\n\nuart.deinit()\n\n\n\n\nGeneral IO Pins\n\n\nOutput Pin example\n\n\n from machine import Pin\n\n pin_out = Pin('P8', mode=Pin.OUT)    # P8 = G15 on Expansion Board\n\n pin_out.id()\n'P8'\n\n\n pin_out.value()\n0\n\n\n pin_out.value(1)\n\n pin_out.value()\n1\n\n\n pin_out.toggle()\n\n pin_out.value()\n0\n\n\n\n\nInput Pin example\n\n\nThe following example calls the \nbutton_pressed()\n function each time the\n\nBUTTON\n (Pin 10) on the Expansion Board is pressed. Implementing this\nthrough callbacks is a lot more efficient than polling the state of the\ninput pin. \n\n\n from machine import Pin\n\n\n def button_pressed(pin):\n...     print('button pressed')\n\n\n pin_in = = Pin('P10', mode=Pin.IN, pull=Pin.PULL_UP)\n\n pin.callback(Pin.IRQ_FALLING, button_pressed)\n\n\n\n\nIdle and deepsleep\n\n\nThere are three functions intended to save power consumption. The first one\nis \nmachine.idle()\n which stops the main script until the next interrupt.\nUnfortunately ion the SiPy the system timer interrupt occurs every few\nmilliseconds so \nmachine.idle()\n has probably very little effect.\n\n\nThe second function is \nmachine.deepsleep(ms)\n and this one does justice to its\nname. Calling \nmachine.deepsleep(ms)\n will stop(!) the CPU and all peripherals\ncompletely for a number of milliseconds. Not even an interrupt will wake the\nsystem from its slumber. The big catch is that the system resets after it wakes\nup again which makes for an interesting programming model:\nwork - deepsleep - reset - work - deepsleep, and so on.\n\n\n import machine\n\n machine.deepsleep(2000)\nets Jun  8 2016 00:22:57\n\nrst:0x5 (DEEPSLEEP_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)\nconfigsip: 0, SPIWP:0x00\nclk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00\nmode:QIO, clock div:1\nload:0x3fff9010,len:12\nho 0 tail 12 room 4\nload:0x3fff9020,len:388\nload:0x40078000,len:11412\nload:0x4009fc00,len:848\nentry 0x4009fd9c\nMicroPython 41c42b2-dirty on 2017-06-28; SiPy with ESP32\nType \nhelp()\n for more information.\n\n\n\n\n\n\n\nFinally there is \nmachine.pin_deepsleep_wakeup()\n which allows the system to\nwake up from deep sleep through a pin. The \nBUTTON\n pin 10 comes to mind.", 
            "title": "Pycom SiPy and Sigfox Introduction to SiPy"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/introduction_to_sipy/#the-pycom-sipy", 
            "text": "The  Pycom SiPy  is a multi-network (Sigfox, WiFi\nand Bluetooth LE) development platform which is programmable with MicroPython . The SiPy can be fitted into the Expansion board  which adds\nUSB power and console access as well as an SD card slot. Pycom also offer\nhardware for LoRaWAN and LTE CAT M1/NB1 networks as well as other expansion\nboards.", 
            "title": "The Pycom Sipy"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/introduction_to_sipy/#connecting-to-the-sipy", 
            "text": "The SiPy can be powered over the Expansion Boards micro-USB port which also\nserves as the serial console.  $ dmesg\n[2371388.193802] usb 5-1: new full-speed USB device number 27 using ohci-pci\n[2371388.357021] usb 5-1: New USB device found, idVendor=0403, idProduct=6015\n[2371388.357033] usb 5-1: New USB device strings: Mfr=1, Product=2, SerialNumber=3\n[2371388.357036] usb 5-1: Product: FT230X Basic UART\n[2371388.357039] usb 5-1: Manufacturer: FTDI\n[2371388.357041] usb 5-1: SerialNumber: DO0039D6\n[2371388.363250] ftdi_sio 5-1:1.0: FTDI USB Serial Device converter detected\n[2371388.363449] usb 5-1: Detected FT-X\n[2371388.367270] usb 5-1: FTDI USB Serial Device converter now attached to ttyUSB0\n\n$ cat /etc/minirc.sipy \npu rtscts           No \npu localecho        No\n\n$ sudo minicom -D /dev/ttyUSB0 --noinit sipy  The console interface actually presents the interactive MicroPython prompt. This is\nreally nice for exploring and prototyping. Check the tutorial and reference sections\nof the  official documentation  to get started.   import os  os.uname()\n(sysname='SiPy', nodename='SiPy', release='1.7.3.b2', version='41c42b2-dirty on 2017-06-26', machine='SiPy with ESP32', sigfox='1.0.1')  Alternatively one can access the SiPy via Telnet but one has to configure the\nWLAN interface first.    from network import WLAN  wlan = WLAN(mode=WLAN.STA)  wlan.ifconfig(config='dhcp')  wlan.scan()\n[(ssid='MYSSID', bssid=b'.......', sec=3, channel=12, rssi=-42)]  WLAN_SSID='MYSSID'  WLAN_KEY='MYKEY'  wlan.connect(ssid=WLAN_SSID, auth=(WLAN.WPA2, WLAN_KEY))  wlan.isconnected()\nTrue  wlan.ifconfig()\n('10.1.1.34', '255.255.255.0', '10.1.1.1', '10.1.1.1')  $ telnet 10.1.1.34\nTrying 10.1.1.34...\nConnected to 10.1.1.34.\nEscape character is '^]'.\nMicroPython 41c42b2-dirty on 2017-06-26; SiPy with ESP32\nLogin as: micro\nPassword: python\nLogin succeeded!\nType  help()  for more information. \nCTRL-C\ntelnet  quit  The SiPy also features a built-in FTP server which is required if one wants to\nupload Python scripts to the device's flash memory.  $ ftp 10.1.1.34\nConnected to 10.1.1.34 (10.1.1.34).\n220 Micropython FTP Server\nName (10.1.1.34:mjuenemann): micro\n331 \nPassword:\n230 \nRemote system type is UNIX.\nUsing binary mode to transfer files.\nftp  ls\n227 (10,1,1,34,7,232)\n150 \ndrw-rw-r--   1 root  root         0 Jan  1  1985 flash\n226 \nftp  cd flash\n250 \nftp  ls\n227 (10,1,1,34,7,232)\n150 \n-rw-rw-r--   1 root  root        34 Jan  1  2098 main.py\ndrw-rw-r--   1 root  root         0 Jan  1  2098 sys\ndrw-rw-r--   1 root  root         0 Jan  1  2098 lib\ndrw-rw-r--   1 root  root         0 Jan  1  2098 cert\n-rw-rw-r--   1 root  root        29 Jan  1  2098 boot.py\n226 \nftp  bye", 
            "title": "Connecting to the SiPy"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/introduction_to_sipy/#the-flashbootpy-and-flashmainpy-scripts", 
            "text": "The  boot.py  and  main.py  script implement the application logic of the SiPy.\nThe purpose of the boot script is to set-up the environment for the main script.\nthe boot script is run once after reset.\nThe main script is executed after the boot script and inherits the namespace, i.e.\nany imports or variables defined in  boot.py  are available in  main.py . The\ndefault main script does nothing and it is up to the application developer\nto create and upload a custom  main.py  script.", 
            "title": "The /flash/boot.py and /flash/main.py scripts"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/introduction_to_sipy/#micropython-on-sipy-examples", 
            "text": "", 
            "title": "MicroPython on SiPy examples"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/introduction_to_sipy/#reading-from-uart", 
            "text": "from machine import UART  uart = UART()  uart.init(baudrate=4800, bits = 8, parity = None, stop = 1, \n              pins = ('P3', 'P4'),     # P3=TX (G21 on Expansion Board), P4=Rx (G11)\n              timeout_chars=10)        # Read timeout in chars/baudrate, if set too low readline() won't work!!!  if uart.any():\n...     uart.readline()\n\nuart.deinit()", 
            "title": "Reading from UART"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/introduction_to_sipy/#general-io-pins", 
            "text": "Output Pin example   from machine import Pin  pin_out = Pin('P8', mode=Pin.OUT)    # P8 = G15 on Expansion Board  pin_out.id()\n'P8'  pin_out.value()\n0  pin_out.value(1)  pin_out.value()\n1  pin_out.toggle()  pin_out.value()\n0  Input Pin example  The following example calls the  button_pressed()  function each time the BUTTON  (Pin 10) on the Expansion Board is pressed. Implementing this\nthrough callbacks is a lot more efficient than polling the state of the\ninput pin.    from machine import Pin  def button_pressed(pin):\n...     print('button pressed')  pin_in = = Pin('P10', mode=Pin.IN, pull=Pin.PULL_UP)  pin.callback(Pin.IRQ_FALLING, button_pressed)", 
            "title": "General IO Pins"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/introduction_to_sipy/#idle-and-deepsleep", 
            "text": "There are three functions intended to save power consumption. The first one\nis  machine.idle()  which stops the main script until the next interrupt.\nUnfortunately ion the SiPy the system timer interrupt occurs every few\nmilliseconds so  machine.idle()  has probably very little effect.  The second function is  machine.deepsleep(ms)  and this one does justice to its\nname. Calling  machine.deepsleep(ms)  will stop(!) the CPU and all peripherals\ncompletely for a number of milliseconds. Not even an interrupt will wake the\nsystem from its slumber. The big catch is that the system resets after it wakes\nup again which makes for an interesting programming model:\nwork - deepsleep - reset - work - deepsleep, and so on.   import machine  machine.deepsleep(2000)\nets Jun  8 2016 00:22:57\n\nrst:0x5 (DEEPSLEEP_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)\nconfigsip: 0, SPIWP:0x00\nclk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00\nmode:QIO, clock div:1\nload:0x3fff9010,len:12\nho 0 tail 12 room 4\nload:0x3fff9020,len:388\nload:0x40078000,len:11412\nload:0x4009fc00,len:848\nentry 0x4009fd9c\nMicroPython 41c42b2-dirty on 2017-06-28; SiPy with ESP32\nType  help()  for more information.   Finally there is  machine.pin_deepsleep_wakeup()  which allows the system to\nwake up from deep sleep through a pin. The  BUTTON  pin 10 comes to mind.", 
            "title": "Idle and deepsleep"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/sending_sigfox_message/", 
            "text": "Sending a Sigfox message\n\n\nSigfox\n\n\nSigfox\n (\nWikipedia\n)\nis a French company that provides an IoT Connectivity Service based on\nthe Sigfox technology. It partners with other companies to operate LPWAN (Low-Power-WAN)\nnetworks in currently 32 countries. As a LPWAN protocol Sigfox trades throughput for\nlow-power consumption and long-battery life. Uplink messages can carry a pay-load of up\nto 12 bytes and there is a limit of at most 140 messages transmissions per day. The\nlatter is a regulatory limitation of the \n\nISM band\n it uses. The official Sigfox standard\ndoesn't seem to be publicly available but there is an\n\nInternet Draft\n\nwhich provides some insights.\n\n\nRegistering the device with Sigfox\n\n\nBefore one can send messages through the Sigfox network on has to first register the hardware with the local Sigfox network provider on\nthe \nonline activation page\n. \nDevelopment kits \"come with an included subscription to the full Sigfox service\"\n(\nSource\n).\nIn my case I had to select \npycom\n as the kit provider and \nThinxtra\n as\nthe Sigfox network operator in Australia.\n\n\n\n\nDetailed instructions for registering\nthe SiPy can be found on the\n\nRegistering the SiPy with Sigfox\n\npage.\n\n\nThe Python script below will display the Device ID and PAC which must be entered\nduring registration.\n\n\n import network, binascii\n\n sigfox = network.Sigfox(mode=network.Sigfox.SIGFOX,\n...                         rcz=network.Sigfox.RCZ4)   # RCZ4 = Asia-Pacific\n\n print(binascii.hexlify(sigfox.id()))\nb'012345678'\n\n print(binascii.hexlify(sigfox.pac()))\nb'0123456789abcdef'\n\n\n\n\n\n\nSending a Sigfox message\n\n\nSending data through the Sigfox network is well described in the manual page\nof the \nSigfox\n\nPython class. The example below sends 3 bytes of payload.\n\n\n import socket\n\n from network import Sigfox\n\n sigfox = Sigfox(mode=Sigfox.SIGFOX, rcz=Sigfox.RCZ4)\n\n s = socket.socket(socket.AF_SIGFOX, socket.SOCK_RAW)\n\n s.setsockopt(socket.SOL_SIGFOX, socket.SO_RX, False)    # Don't expect downlink msg\n\n s.setblocking(True)\n\n s.send(bytes([0,127,255]))\n3\n\n s.close()\n\n\n\n\nThe Sigfox Backend\n\n\nThe Sigfox network will receive the message but not do anything with it unless one\nconfigures a callback. Typically one would forward the message for processing. At\nthe moment there are pre-configured templates for Amazon Web Servicess and\nMicrosoft Azure as well as the option to create a custom callback.\n\n\n\n\nFor debugging purposes one can simply create a custom callback that will decode\nthe Sigfox message and send the decoded data as an email as shown below.\n\n\n\n\nThe resulting email body would look like shown below. Note how the second and third byte\nwere interpreted as a 16-bit unsigned integer. The latitude and longitude (of the\nreceiving basestation) are always rounded to the nearest integer and are therefore\nof limited use. The timestamp is in Unix epoch, i.e. seconds since 1-Jan-1970 which will\nprobably be within 1 or 2 seconds from when the message was originally sent. I didn't\nactually test this!\n\n\nDevice: 4D1234\nTime: 1498034856\nDuplicate: false\nSNR: 40.54\nStation: 2322\nData: 007fff\nAvgSnr: 40.89\nLat: -38.0\nLong: 145.0\nRSSI: -103.00\nSeqNumber: 4\nValue1: 0\nValue2: 32767", 
            "title": "Pycom SiPy and Sigfox Sending Sigfox message"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/sending_sigfox_message/#sending-a-sigfox-message", 
            "text": "", 
            "title": "Sending a Sigfox message"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/sending_sigfox_message/#sigfox", 
            "text": "Sigfox  ( Wikipedia )\nis a French company that provides an IoT Connectivity Service based on\nthe Sigfox technology. It partners with other companies to operate LPWAN (Low-Power-WAN)\nnetworks in currently 32 countries. As a LPWAN protocol Sigfox trades throughput for\nlow-power consumption and long-battery life. Uplink messages can carry a pay-load of up\nto 12 bytes and there is a limit of at most 140 messages transmissions per day. The\nlatter is a regulatory limitation of the  ISM band  it uses. The official Sigfox standard\ndoesn't seem to be publicly available but there is an Internet Draft \nwhich provides some insights.", 
            "title": "Sigfox"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/sending_sigfox_message/#registering-the-device-with-sigfox", 
            "text": "Before one can send messages through the Sigfox network on has to first register the hardware with the local Sigfox network provider on\nthe  online activation page . \nDevelopment kits \"come with an included subscription to the full Sigfox service\"\n( Source ).\nIn my case I had to select  pycom  as the kit provider and  Thinxtra  as\nthe Sigfox network operator in Australia.   Detailed instructions for registering\nthe SiPy can be found on the Registering the SiPy with Sigfox \npage.  The Python script below will display the Device ID and PAC which must be entered\nduring registration.   import network, binascii  sigfox = network.Sigfox(mode=network.Sigfox.SIGFOX,\n...                         rcz=network.Sigfox.RCZ4)   # RCZ4 = Asia-Pacific  print(binascii.hexlify(sigfox.id()))\nb'012345678'  print(binascii.hexlify(sigfox.pac()))\nb'0123456789abcdef'", 
            "title": "Registering the device with Sigfox"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/sending_sigfox_message/#sending-a-sigfox-message_1", 
            "text": "Sending data through the Sigfox network is well described in the manual page\nof the  Sigfox \nPython class. The example below sends 3 bytes of payload.   import socket  from network import Sigfox  sigfox = Sigfox(mode=Sigfox.SIGFOX, rcz=Sigfox.RCZ4)  s = socket.socket(socket.AF_SIGFOX, socket.SOCK_RAW)  s.setsockopt(socket.SOL_SIGFOX, socket.SO_RX, False)    # Don't expect downlink msg  s.setblocking(True)  s.send(bytes([0,127,255]))\n3  s.close()", 
            "title": "Sending a Sigfox message"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/sending_sigfox_message/#the-sigfox-backend", 
            "text": "The Sigfox network will receive the message but not do anything with it unless one\nconfigures a callback. Typically one would forward the message for processing. At\nthe moment there are pre-configured templates for Amazon Web Servicess and\nMicrosoft Azure as well as the option to create a custom callback.   For debugging purposes one can simply create a custom callback that will decode\nthe Sigfox message and send the decoded data as an email as shown below.   The resulting email body would look like shown below. Note how the second and third byte\nwere interpreted as a 16-bit unsigned integer. The latitude and longitude (of the\nreceiving basestation) are always rounded to the nearest integer and are therefore\nof limited use. The timestamp is in Unix epoch, i.e. seconds since 1-Jan-1970 which will\nprobably be within 1 or 2 seconds from when the message was originally sent. I didn't\nactually test this!  Device: 4D1234\nTime: 1498034856\nDuplicate: false\nSNR: 40.54\nStation: 2322\nData: 007fff\nAvgSnr: 40.89\nLat: -38.0\nLong: 145.0\nRSSI: -103.00\nSeqNumber: 4\nValue1: 0\nValue2: 32767", 
            "title": "The Sigfox Backend"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/sigfox_backend/", 
            "text": "Sigfox backend service", 
            "title": "Pycom SiPy and Sigfox Sending Sigfox message"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/sigfox_backend/#sigfox-backend-service", 
            "text": "", 
            "title": "Sigfox backend service"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/sigfox_downlink/", 
            "text": "Sigfox downlink messages", 
            "title": "Pycom SiPy and Sigfox Sending Sigfox message"
        }, 
        {
            "location": "/iot/pycom_sipy_sigfox/sigfox_downlink/#sigfox-downlink-messages", 
            "text": "", 
            "title": "Sigfox downlink messages"
        }
    ]
}