{
    "docs": [
        {
            "location": "/", 
            "text": "Projects and Notes\n\n\nBelow are a list of notes and projects I have been working on. I use this page mainly \nfor my own reference but other people might find something useful.\n\n\nCloud Computing\n\n\n\n\n'Terraform: Up \n Running' code samples translated\n\n\n\n\nSoftware Development\n\n\n\n\nMy collection of IPython notebooks\n\n\nTesting Python Code with Hypothesis\n\n\n\n\nNetworking\n\n\n\n\nInstalling GNS3 on CentOS 7\n\n\nBasic IPv6 on Cisco IOS\n\n\n802.11s Wireless Mesh Network\n\n\n\n\nLinks\n\n\nMy other presence on the Internet.\n\n\n\n\nGithub\n\n\nLinkedIn\n\n\nTravis-CI", 
            "title": "Home"
        }, 
        {
            "location": "/#projects-and-notes", 
            "text": "Below are a list of notes and projects I have been working on. I use this page mainly \nfor my own reference but other people might find something useful.", 
            "title": "Projects and Notes"
        }, 
        {
            "location": "/#cloud-computing", 
            "text": "'Terraform: Up   Running' code samples translated", 
            "title": "Cloud Computing"
        }, 
        {
            "location": "/#software-development", 
            "text": "My collection of IPython notebooks  Testing Python Code with Hypothesis", 
            "title": "Software Development"
        }, 
        {
            "location": "/#networking", 
            "text": "Installing GNS3 on CentOS 7  Basic IPv6 on Cisco IOS  802.11s Wireless Mesh Network", 
            "title": "Networking"
        }, 
        {
            "location": "/#links", 
            "text": "My other presence on the Internet.   Github  LinkedIn  Travis-CI", 
            "title": "Links"
        }, 
        {
            "location": "/installing_gns3_on_centos7/", 
            "text": "Installing GNS3 on CentOS 7\n\n\nGNS3 is a popular network software emulator. It uses the Dynamips emulation software\nto simulate Cisco IOS. The official documentation includes installation guides for\nUbuntu, Debian, Arch Linux, Fedora and OpenSuse. This article explains how to install\nGNS3 on CentOS 7.\n\n\nRequirements\n\n\nGNS3 is written in Python 3, Python 2 is not supported. The Python 3 packages are not\navailable through the CentOS RPM repositories but they are available on EPEL.\nThe steps below add the EPEL repository, install Python 3.4, QT5 and various other\npackages that are either needed or are useful for running GNS3.\n\n\nsudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\nsudo yum install python34 python34-devel python34-setuptools python34-tools\nsudo yum install elfutils-libelf-devel libpcap-devel cmake glibc-static qemu telnet gnome-terminal putty\nsudo yum install qt5-qtbase qt5-qtbase-devel qt5-qtsvg qt5-qtsvg-devel\nsudo yum groupinstall Fonts\ncurl https://bootstrap.pypa.io/get-pip.py | sudo python3.4\n\n\n\n\nGNS3\n\n\nOnce Python 3.4 has been installed, the latest GNS3 releases are available from PyPi \nand are easily installed through the pip3.4 script.\n\n\nsudo pip3.4 install gns3-server gns3-gui\n\n\n\n\nQt5 and Python 3 bindings\n\n\nGNS3 relies on the Python 3 bindings for the QT5 toolkit. These are not available for\nCentOS 7 from any repository and must be installed from source code. This section is\nheavily based on the instructions found at \n\nhttp://robertbasic.com/blog/install-pyqt5-in-python-3-virtual-environment/\n.\n\n\nSIP\n\n\ncd /tmp\nwget http://sourceforge.net/projects/pyqt/files/sip/sip-4.16.5/sip-4.16.5.tar.gz\ntar xvfz sip-4.16.5.tar.gz\ncd sip-4.16.5\npython3.4 configure.py\nmake\nsudo make install\n\n\n\n\n\nPyQt5\n\n\nBuilding PyQt5 from source will take a while.\n\n\ncd /tmp\nwget http://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4/PyQt-gpl-5.4.tar.gz\ntar xzf PyQt-gpl-5.4.tar.gz\ncd PyQt-gpl-5.4\npython3.4 configure.py --qmake /usr/bin/qmake-qt5\nmake\nsudo make install\n\n\n\n\n\nDynamips\n\n\nDynamips is a Cisco router emulator. It started as a separate project in 2005 but the\nsources are now part of the GNS3 repositories on Github.\n\n\ncd /tmp\ngit clone https://github.com/GNS3/dynamips.git\ncd dynamips/\nmkdir build\ncd build/\ncmake .. -DDYNAMIPS_CODE=stable\nmake\nsudo make install\n\n\n\n\n\nVPCS\n\n\nThe Virtual PC Simulator (VPCS) can be used in GNS3 to add simple PCs to a network\ntopology. The steps below will install the /usr/local/bin/vpcs from source code.\n\n\ncd /tmp\nsvn checkout http://svn.code.sf.net/p/vpcs/code/trunk vpcs\ncd vpcs/src\n./mk.sh 64\nsudo install -m 755 vpcs /usr/local/bin\n\n\n\n\n\nThat's all.", 
            "title": "Installing GNS3 on CentOS 7"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#installing-gns3-on-centos-7", 
            "text": "GNS3 is a popular network software emulator. It uses the Dynamips emulation software\nto simulate Cisco IOS. The official documentation includes installation guides for\nUbuntu, Debian, Arch Linux, Fedora and OpenSuse. This article explains how to install\nGNS3 on CentOS 7.", 
            "title": "Installing GNS3 on CentOS 7"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#requirements", 
            "text": "GNS3 is written in Python 3, Python 2 is not supported. The Python 3 packages are not\navailable through the CentOS RPM repositories but they are available on EPEL.\nThe steps below add the EPEL repository, install Python 3.4, QT5 and various other\npackages that are either needed or are useful for running GNS3.  sudo yum install https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm\nsudo yum install python34 python34-devel python34-setuptools python34-tools\nsudo yum install elfutils-libelf-devel libpcap-devel cmake glibc-static qemu telnet gnome-terminal putty\nsudo yum install qt5-qtbase qt5-qtbase-devel qt5-qtsvg qt5-qtsvg-devel\nsudo yum groupinstall Fonts\ncurl https://bootstrap.pypa.io/get-pip.py | sudo python3.4", 
            "title": "Requirements"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#gns3", 
            "text": "Once Python 3.4 has been installed, the latest GNS3 releases are available from PyPi \nand are easily installed through the pip3.4 script.  sudo pip3.4 install gns3-server gns3-gui", 
            "title": "GNS3"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#qt5-and-python-3-bindings", 
            "text": "GNS3 relies on the Python 3 bindings for the QT5 toolkit. These are not available for\nCentOS 7 from any repository and must be installed from source code. This section is\nheavily based on the instructions found at  http://robertbasic.com/blog/install-pyqt5-in-python-3-virtual-environment/ .", 
            "title": "Qt5 and Python 3 bindings"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#sip", 
            "text": "cd /tmp\nwget http://sourceforge.net/projects/pyqt/files/sip/sip-4.16.5/sip-4.16.5.tar.gz\ntar xvfz sip-4.16.5.tar.gz\ncd sip-4.16.5\npython3.4 configure.py\nmake\nsudo make install", 
            "title": "SIP"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#pyqt5", 
            "text": "Building PyQt5 from source will take a while.  cd /tmp\nwget http://sourceforge.net/projects/pyqt/files/PyQt5/PyQt-5.4/PyQt-gpl-5.4.tar.gz\ntar xzf PyQt-gpl-5.4.tar.gz\ncd PyQt-gpl-5.4\npython3.4 configure.py --qmake /usr/bin/qmake-qt5\nmake\nsudo make install", 
            "title": "PyQt5"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#dynamips", 
            "text": "Dynamips is a Cisco router emulator. It started as a separate project in 2005 but the\nsources are now part of the GNS3 repositories on Github.  cd /tmp\ngit clone https://github.com/GNS3/dynamips.git\ncd dynamips/\nmkdir build\ncd build/\ncmake .. -DDYNAMIPS_CODE=stable\nmake\nsudo make install", 
            "title": "Dynamips"
        }, 
        {
            "location": "/installing_gns3_on_centos7/#vpcs", 
            "text": "The Virtual PC Simulator (VPCS) can be used in GNS3 to add simple PCs to a network\ntopology. The steps below will install the /usr/local/bin/vpcs from source code.  cd /tmp\nsvn checkout http://svn.code.sf.net/p/vpcs/code/trunk vpcs\ncd vpcs/src\n./mk.sh 64\nsudo install -m 755 vpcs /usr/local/bin  That's all.", 
            "title": "VPCS"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/", 
            "text": "Basic IPv6 on Cisco IOS\n\n\nGlobal settings\n\n\nThere are a couple of global settings that enable IPv6 on a Cisco router. The example below also shows two host name to IPv6 address mappings.\n\n\nip routing\nipv6 unicast-routing\n\nip cef\nipv6 cef\n\nipv6 host R1 FDFC:38C4:F0BE:FFFF::1\nipv6 host R2 FDFC:38C4:F0BE:FFFF::2\n\n\n\n\nInterfaces\n\n\nThe example below shows a dual-stack configuration for an Ethernet interface. \n\nFDFC:38C4:F0BE/48\n is the unique-local address (ULA) prefix registered with \nthe \nIPv6 ULA (Unique Local Address) RFC4193 Registration List\n.\nThe IPv6 subnet on this interface is \n...:1::...\n and the host address is \n...::1\n.\n\n\n# sh run int e1/0\ninterface Ethernet1/0\n ip address 192.168.1.1 255.255.255.0\n ipv6 address FDFC:38C4:F0BE:1::1/64\n ipv6 enable\n\n\n\n\nThe loopback interface is on IPv6 subnet \nFFFF\n. Like its IPv4 address, \nits IPv6 address has a netmask with all bits set (/128).\n\n\n# sh run int lo0\ninterface Loopback0\n ip address 192.168.255.1 255.255.255.255\n ipv6 address FDFC:38C4:F0BE:FFFF::1/128\n ipv6 enable\n\n\n\n\nThe show ipv6 interface command displays IPv6 information for that interface\n\n\n# sh ipv6 interface e1/0\nEthernet1/0 is up, line protocol is up\n  IPv6 is enabled, link-local address is FE80::C801:32FF:FE70:1C\n  Global unicast address(es):\n    FDFC:38C4:F0BE:1::1, subnet is FDFC:38C4:F0BE:1::/64\n  Joined group address(es):\n    FF02::1\n    FF02::2\n    FF02::1:FF00:1\n    FF02::1:FF70:1C\n  MTU is 1500 bytes\n  ICMP error messages limited to one every 100 milliseconds\n  ICMP redirects are enabled\n  ND DAD is enabled, number of DAD attempts: 1\n  ND reachable time is 30000 milliseconds\n  ND advertised reachable time is 0 milliseconds\n  ND advertised retransmit interval is 0 milliseconds\n  ND router advertisements are sent every 200 seconds\n  ND router advertisements live for 1800 seconds\n  Hosts use stateless autoconfig for addresses.\n192.168.1.1/24 (IPv4)\nFDFC:38C4:F0BE:1::1/64 (IPv6 unique-local address; ULA)\nFE80::... (IPv6 link local)\nff02::1 (All nodes on the local network segment)\nFF02::2 (All routers on the local network segment)\nFF02::1:FF00:1 (Solicited-node multicast address; used for Neighbour-Disovery)\nFF02::1:FF70:1C (???)\n\n\n\n\nShow IPv6 ...\n\n\nNeighbor Cache\n\n\n# sh ipv6 neighbors [e1/0]\nIPv6 Address                              Age Link-layer Addr State Interface\nFE80::C802:32FF:FE7F:1C                     0 ca02.327f.001c  REACH Et1/0\nFDFC:38C4:F0BE:1::2                         0 ca02.327f.001c  STALE Et1/0\n\n\n\n\nRoutes\n\n\n# sh ipv6 route\nIPv6 Routing Table - 6 entries\nCodes: C - Connected, L - Local, S - Static, R - RIP, B - BGP\n       U - Per-user Static route\n       I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea, IS - ISIS summary\n       O - OSPF intra, OI - OSPF inter, OE1 - OSPF ext 1, OE2 - OSPF ext 2\n       ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2\nC   FDFC:38C4:F0BE:1::/64 [0/0]\n     via ::, Ethernet1/0\nL   FDFC:38C4:F0BE:1::1/128 [0/0]\n     via ::, Ethernet1/0\nC   FDFC:38C4:F0BE:4::/64 [0/0]\n     via ::, Ethernet1/1\nL   FDFC:38C4:F0BE:4::1/128 [0/0]\n     via ::, Ethernet1/1\nL   FE80::/10 [0/0]\n     via ::, Null0\nL   FF00::/8 [0/0]\n     via ::, Null0\n\n\n\n\nOSPFv3\n\n\nOSPFv3 expands on OSPF version 2 to provide support for IPv6 routing prefixes and\nthe larger size of IPv6 addresses. In regards to configuring OSPFv3 on Cisco IOS there\nare two key differences to OSPFv2.\n\n\n\n\nIn OSPFv3, a routing process does not need to be explicitly created. Enabling OSPFv3\n  on an interface will cause a routing process, and its associated configuration,\n  to be created. One may still want to customise OSPFv3 parameters that are not\n  interface specific.\n\n\nIn OSPFv3, each interface must be enabled using commands in interface configuration\n  mode. This feature is different from OSPF version 2, in which interfaces are\n  indirectly enabled using the device configuration mode.\n\n\n\n\nOSPFv3 can be used for IPv6 and IPv4 as long as separate OSPF processes are used.\nYou may want to use OSPFv2 for IPv4 and OSPFv3 only for IPv6. The example below\nconfigures a single OSPFv3 zone for IPv6 only.\n\n\nEnabling OSPFv3 authentication is so simple that there is no reason for not doing so.\n\n\n# sh run\ninterface Ethernet1/0\n  ...\n  ipv6 ospf 1 area 0\n\nipv6 router ospf 1\n log-adjacency-changes\n redistribute connected\n area 0 authentication ipsec spi 1000 md5 8B800BD784E62C8C8B0A8DEA3451A25E", 
            "title": "Basic IPv6 on Cisco IOS"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#basic-ipv6-on-cisco-ios", 
            "text": "", 
            "title": "Basic IPv6 on Cisco IOS"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#global-settings", 
            "text": "There are a couple of global settings that enable IPv6 on a Cisco router. The example below also shows two host name to IPv6 address mappings.  ip routing\nipv6 unicast-routing\n\nip cef\nipv6 cef\n\nipv6 host R1 FDFC:38C4:F0BE:FFFF::1\nipv6 host R2 FDFC:38C4:F0BE:FFFF::2", 
            "title": "Global settings"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#interfaces", 
            "text": "The example below shows a dual-stack configuration for an Ethernet interface.  FDFC:38C4:F0BE/48  is the unique-local address (ULA) prefix registered with \nthe  IPv6 ULA (Unique Local Address) RFC4193 Registration List .\nThe IPv6 subnet on this interface is  ...:1::...  and the host address is  ...::1 .  # sh run int e1/0\ninterface Ethernet1/0\n ip address 192.168.1.1 255.255.255.0\n ipv6 address FDFC:38C4:F0BE:1::1/64\n ipv6 enable  The loopback interface is on IPv6 subnet  FFFF . Like its IPv4 address, \nits IPv6 address has a netmask with all bits set (/128).  # sh run int lo0\ninterface Loopback0\n ip address 192.168.255.1 255.255.255.255\n ipv6 address FDFC:38C4:F0BE:FFFF::1/128\n ipv6 enable  The show ipv6 interface command displays IPv6 information for that interface  # sh ipv6 interface e1/0\nEthernet1/0 is up, line protocol is up\n  IPv6 is enabled, link-local address is FE80::C801:32FF:FE70:1C\n  Global unicast address(es):\n    FDFC:38C4:F0BE:1::1, subnet is FDFC:38C4:F0BE:1::/64\n  Joined group address(es):\n    FF02::1\n    FF02::2\n    FF02::1:FF00:1\n    FF02::1:FF70:1C\n  MTU is 1500 bytes\n  ICMP error messages limited to one every 100 milliseconds\n  ICMP redirects are enabled\n  ND DAD is enabled, number of DAD attempts: 1\n  ND reachable time is 30000 milliseconds\n  ND advertised reachable time is 0 milliseconds\n  ND advertised retransmit interval is 0 milliseconds\n  ND router advertisements are sent every 200 seconds\n  ND router advertisements live for 1800 seconds\n  Hosts use stateless autoconfig for addresses.\n192.168.1.1/24 (IPv4)\nFDFC:38C4:F0BE:1::1/64 (IPv6 unique-local address; ULA)\nFE80::... (IPv6 link local)\nff02::1 (All nodes on the local network segment)\nFF02::2 (All routers on the local network segment)\nFF02::1:FF00:1 (Solicited-node multicast address; used for Neighbour-Disovery)\nFF02::1:FF70:1C (???)", 
            "title": "Interfaces"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#show-ipv6", 
            "text": "", 
            "title": "Show IPv6 ..."
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#neighbor-cache", 
            "text": "# sh ipv6 neighbors [e1/0]\nIPv6 Address                              Age Link-layer Addr State Interface\nFE80::C802:32FF:FE7F:1C                     0 ca02.327f.001c  REACH Et1/0\nFDFC:38C4:F0BE:1::2                         0 ca02.327f.001c  STALE Et1/0", 
            "title": "Neighbor Cache"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#routes", 
            "text": "# sh ipv6 route\nIPv6 Routing Table - 6 entries\nCodes: C - Connected, L - Local, S - Static, R - RIP, B - BGP\n       U - Per-user Static route\n       I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea, IS - ISIS summary\n       O - OSPF intra, OI - OSPF inter, OE1 - OSPF ext 1, OE2 - OSPF ext 2\n       ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2\nC   FDFC:38C4:F0BE:1::/64 [0/0]\n     via ::, Ethernet1/0\nL   FDFC:38C4:F0BE:1::1/128 [0/0]\n     via ::, Ethernet1/0\nC   FDFC:38C4:F0BE:4::/64 [0/0]\n     via ::, Ethernet1/1\nL   FDFC:38C4:F0BE:4::1/128 [0/0]\n     via ::, Ethernet1/1\nL   FE80::/10 [0/0]\n     via ::, Null0\nL   FF00::/8 [0/0]\n     via ::, Null0", 
            "title": "Routes"
        }, 
        {
            "location": "/basic_ipv6_on_cisco_ios/#ospfv3", 
            "text": "OSPFv3 expands on OSPF version 2 to provide support for IPv6 routing prefixes and\nthe larger size of IPv6 addresses. In regards to configuring OSPFv3 on Cisco IOS there\nare two key differences to OSPFv2.   In OSPFv3, a routing process does not need to be explicitly created. Enabling OSPFv3\n  on an interface will cause a routing process, and its associated configuration,\n  to be created. One may still want to customise OSPFv3 parameters that are not\n  interface specific.  In OSPFv3, each interface must be enabled using commands in interface configuration\n  mode. This feature is different from OSPF version 2, in which interfaces are\n  indirectly enabled using the device configuration mode.   OSPFv3 can be used for IPv6 and IPv4 as long as separate OSPF processes are used.\nYou may want to use OSPFv2 for IPv4 and OSPFv3 only for IPv6. The example below\nconfigures a single OSPFv3 zone for IPv6 only.  Enabling OSPFv3 authentication is so simple that there is no reason for not doing so.  # sh run\ninterface Ethernet1/0\n  ...\n  ipv6 ospf 1 area 0\n\nipv6 router ospf 1\n log-adjacency-changes\n redistribute connected\n area 0 authentication ipsec spi 1000 md5 8B800BD784E62C8C8B0A8DEA3451A25E", 
            "title": "OSPFv3"
        }, 
        {
            "location": "/testing_python_code_with_hypothesis/", 
            "text": "Testing Python code with Hypothesis\n\n\nAccording to its \nweb page\n \"Hypothesis is a new generation\nof tools for automating your\ntesting process. It combines human understanding of your problem domain with machine\nintelligence to improve the quality of your testing process while spendingless time\nwriting tests.\" That sounds all nice and fancy but what does this in mean in practice?\nThis article provides a quick introduction to Hypothesis, just to whet your appetite.\nThe \nofficial documentation\n\nprovides a more extensive tutorial.\n\n\nHypothesis is available on PyPi and can be easily installed through pip. Hypothesis\nworks in conjunction with a Python test suite. My personal preference is \n\nNose\n but\nothers are supported, too.\n\n\n$ pip install hypothesis nose\nCollecting hypothesis\nCollecting nose\n  Using cached nose-1.3.7-py2-none-any.whl\nCollecting enum34 (from hypothesis)\n  Using cached enum34-1.1.6-py2-none-any.whl\nInstalling collected packages: enum34, hypothesis, nose\nSuccessfully installed enum34-1.1.6 hypothesis-3.6.1 nose-1.3.7\n\n\n\n\nFor the purpose of this article I am going to explain how Hypothesis works with a\nsimple custom \ndivision()\n function that accepts numbers or strings containing numbers.\nI admit that this example is rather contrived but it serves the purpose of this article\nreally well. The first listing implements the test functions with some assistance\nof Nose.\n\n\n# example1.py\nfrom nose.tools import raises\n\ndef division(x, y):\n    return float(x) / float(y)\n\ndef test_div():\n    \nTest numbers and strings.\n\n    assert division(4, 2.0) == division('4', '2.0')\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n    \nTest division by zero.\n\n    division('4', 0)\n\n\n\n\nWhat is immediately obvious is that only a very limited set of possible arguments to\n\ndivision()\n is tested. Most people can immediately think of additional combinations of\nintegers, floats and string representations worth testing.\n\n\n$ nosetests example1.py \n..\n----------------------------------------------------------------------\nRan 2 tests in 0.000s\n\nOK\n\n\n\n\nThe second example adds tests for numbers from 1 to 10, also as floats and strings.\n\n\n# example2.py\n\nfrom nose.tools import raises\n\ndef division(x, y):\n    return float(x) / float(y)\n\ndef check_division(x, y):\n    assert division(x, y) == 2.0\n\ndef test_div():\n    \nTest numbers and strings.\n\n    for i in range(1, 10):\n        yield division, i*2, i\n        yield division, float(i*2), i\n        yield division, i*2, float(i)\n        yield division, float(i*2), float(i)\n        yield division, i*2, str(i)\n        yield division, str(i*2), i\n        # and so forth...\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n    \nTest division by zero.\n\ufeff\ufeff\n    division('4', 0)\n\n\n\n\nIt covers many more combinations, but is still limited to a tiny subset of possible\nnumbers. It also doesn't look very elegant?\n\n\n$ nosetests example2.py \n.......................................................\n----------------------------------------------------------------------\nRan 55 tests in 0.005s\nOK\n\n\n\n\nLike the first example it provides a specific test case for the ZeroDivisionError\nexception. But are there any other special cases? Maybe Hypothesis can find one.\n\n\nThe key objective of Hypothesis is to generate input data for test functions. And\nit does so very cleverly. Let's rewrite the test and use Hypothesis. Through\nthe \n@given\n decorator Hypothesis will create a series of integers to the test.\n\n\n# example3.py\n\nfrom nose.tools import raises\nfrom hypothesis import given\nfrom hypothesis.strategies import integers\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(x=integers())\ndef test_div(x):\n    \nTest integers.\n\n    print x               # show value of x, normally not done!\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n    \nTest division by zero.\n\ufeff\ufeff\n    division('4', 0)\n\n\n\n\nUnfortunately the \n@given(x=integers())\n line introduces the ZeroDivisionError into\nthe test. This was bound to happen as 0 is a valid integer. Note that the output\nclearly shows what input caused the test to fail (\nFalsifying example: ...\n) and\nbecause of the print statement in the code it also shows the different other integer\nvalues Hypothesis tried.\n\n\n$ nosetests example3.py \nE.\n======================================================================\nERROR: example3.test_div\n----------------------------------------------------------------------\nTraceback (most recent call last):\n[...]\nZeroDivisionError: float division by zero\n-------------------- \n begin captured stdout \n ---------------------\n-86\n38698778983165550746815151433416776989\n130775184150007723213375339326718763618\n-149\n-60717049783932157206209978973119425965\n0\n0\n0\nFalsifying example: test_div(x=0)\n0\n--------------------- \n end captured stdout \n ----------------------\n----------------------------------------------------------------------\nRan 2 tests in 0.011s\nFAILED (errors=1)\n\n\n\n\nQuite clearly we have to amend the code to prevent Hypothesis causing the\nZeroDivisionError exception. The assume function serves this purpose.\n\n\n# example4.py\n\nfrom nose.tools import raises\nfrom hypothesis import given, assume\nfrom hypothesis.strategies import integers\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(x=integers())\ndef test_div(x):\n    \nTest non-zero integers.\n\n    assume(x \n 0)                      # \n-----------\n\n    print x    # show value of x, normally not done!\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n    \nTest division by zero.\n\n    division('4', 0)\nNow the tests pass.\n\n$ nosetests example4.py \n..\n----------------------------------------------------------------------\nRan 2 tests in 0.045s\nOK\n\n\n\n\nBut what about other numbers than integers? The next example adds floats to the mix.\n\n\n# example5.py\n\n\ufefffrom nose.tools import raises\nfrom hypothesis import given, assume\nfrom hypothesis.strategies import integers, floats, one_of\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(one_of(integers(), floats()))       # \n-----------\ndef test_div(x):\n    \nTest integers and floats.\n\ufeff\n    assume(x \n 0)\n    print x\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n    \nTest division by zero.\n\ufeff\ufeff\ufeff\n    division('4', 0)\n\n\n\n\nInterestingly adding floats causes some trouble with really large values\nlike 8.98846567431158e+307 in this example.\n\n\n$ nosetests example5.py\nF.\n======================================================================\nFAIL: example5.test_div\n----------------------------------------------------------------------\nTraceback (most recent call last):\n[...]\n    assert division(x*2, x) == 2.0\nAssertionError: \n-------------------- \n begin captured stdout \n ---------------------\n[...]\n2.38756119474e+307\n8.9873684495e+307\n8.98846567431e+307\nFalsifying example: test_div(x=8.98846567431158e+307)\n8.98846567431e+307\n--------------------- \n end captured stdout \n ----------------------\n----------------------------------------------------------------------\nRan 2 tests in 0.500s\nFAILED (failures=1)\n\n\n\n\nThe cause of the failure becomes obvious when one executes the mathematical\noperation in the Python shell.\n\n\n 8.98846567431158e+307*2/8.98846567431158e+307 == 2.0\nFalse\n\n\n 8.98846567431158e+307*2/8.98846567431158e+307\ninf\n\n\n 8.98846567431158e+307*2\ninf\n\n\n\n\nHypothesis is really good at finding such corner-cases. Although in this example\nit does not actually break the \ndivision()\n function, few people would have thought\nof this case without the help of Hypothesis. I certainly hadn't.\n\n\nI hope this article provided a very brief introduction to Hypothesis and what value\nit adds to testing Python code. Check out the Hypothesis documentation as there\nare many more features.\n\n\nI plan to add Hypothesis based testing to my Python projects\nsoon but I somehow fear the outcome ;-)", 
            "title": "Testing Python Code with Hypothesis"
        }, 
        {
            "location": "/testing_python_code_with_hypothesis/#testing-python-code-with-hypothesis", 
            "text": "According to its  web page  \"Hypothesis is a new generation\nof tools for automating your\ntesting process. It combines human understanding of your problem domain with machine\nintelligence to improve the quality of your testing process while spendingless time\nwriting tests.\" That sounds all nice and fancy but what does this in mean in practice?\nThis article provides a quick introduction to Hypothesis, just to whet your appetite.\nThe  official documentation \nprovides a more extensive tutorial.  Hypothesis is available on PyPi and can be easily installed through pip. Hypothesis\nworks in conjunction with a Python test suite. My personal preference is  Nose  but\nothers are supported, too.  $ pip install hypothesis nose\nCollecting hypothesis\nCollecting nose\n  Using cached nose-1.3.7-py2-none-any.whl\nCollecting enum34 (from hypothesis)\n  Using cached enum34-1.1.6-py2-none-any.whl\nInstalling collected packages: enum34, hypothesis, nose\nSuccessfully installed enum34-1.1.6 hypothesis-3.6.1 nose-1.3.7  For the purpose of this article I am going to explain how Hypothesis works with a\nsimple custom  division()  function that accepts numbers or strings containing numbers.\nI admit that this example is rather contrived but it serves the purpose of this article\nreally well. The first listing implements the test functions with some assistance\nof Nose.  # example1.py\nfrom nose.tools import raises\n\ndef division(x, y):\n    return float(x) / float(y)\n\ndef test_div():\n     Test numbers and strings. \n    assert division(4, 2.0) == division('4', '2.0')\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n     Test division by zero. \n    division('4', 0)  What is immediately obvious is that only a very limited set of possible arguments to division()  is tested. Most people can immediately think of additional combinations of\nintegers, floats and string representations worth testing.  $ nosetests example1.py \n..\n----------------------------------------------------------------------\nRan 2 tests in 0.000s\n\nOK  The second example adds tests for numbers from 1 to 10, also as floats and strings.  # example2.py\n\nfrom nose.tools import raises\n\ndef division(x, y):\n    return float(x) / float(y)\n\ndef check_division(x, y):\n    assert division(x, y) == 2.0\n\ndef test_div():\n     Test numbers and strings. \n    for i in range(1, 10):\n        yield division, i*2, i\n        yield division, float(i*2), i\n        yield division, i*2, float(i)\n        yield division, float(i*2), float(i)\n        yield division, i*2, str(i)\n        yield division, str(i*2), i\n        # and so forth...\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n     Test division by zero. \ufeff\ufeff\n    division('4', 0)  It covers many more combinations, but is still limited to a tiny subset of possible\nnumbers. It also doesn't look very elegant?  $ nosetests example2.py \n.......................................................\n----------------------------------------------------------------------\nRan 55 tests in 0.005s\nOK  Like the first example it provides a specific test case for the ZeroDivisionError\nexception. But are there any other special cases? Maybe Hypothesis can find one.  The key objective of Hypothesis is to generate input data for test functions. And\nit does so very cleverly. Let's rewrite the test and use Hypothesis. Through\nthe  @given  decorator Hypothesis will create a series of integers to the test.  # example3.py\n\nfrom nose.tools import raises\nfrom hypothesis import given\nfrom hypothesis.strategies import integers\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(x=integers())\ndef test_div(x):\n     Test integers. \n    print x               # show value of x, normally not done!\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n     Test division by zero. \ufeff\ufeff\n    division('4', 0)  Unfortunately the  @given(x=integers())  line introduces the ZeroDivisionError into\nthe test. This was bound to happen as 0 is a valid integer. Note that the output\nclearly shows what input caused the test to fail ( Falsifying example: ... ) and\nbecause of the print statement in the code it also shows the different other integer\nvalues Hypothesis tried.  $ nosetests example3.py \nE.\n======================================================================\nERROR: example3.test_div\n----------------------------------------------------------------------\nTraceback (most recent call last):\n[...]\nZeroDivisionError: float division by zero\n--------------------   begin captured stdout   ---------------------\n-86\n38698778983165550746815151433416776989\n130775184150007723213375339326718763618\n-149\n-60717049783932157206209978973119425965\n0\n0\n0\nFalsifying example: test_div(x=0)\n0\n---------------------   end captured stdout   ----------------------\n----------------------------------------------------------------------\nRan 2 tests in 0.011s\nFAILED (errors=1)  Quite clearly we have to amend the code to prevent Hypothesis causing the\nZeroDivisionError exception. The assume function serves this purpose.  # example4.py\n\nfrom nose.tools import raises\nfrom hypothesis import given, assume\nfrom hypothesis.strategies import integers\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(x=integers())\ndef test_div(x):\n     Test non-zero integers. \n    assume(x   0)                      #  -----------\n\n    print x    # show value of x, normally not done!\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n     Test division by zero. \n    division('4', 0)\nNow the tests pass.\n\n$ nosetests example4.py \n..\n----------------------------------------------------------------------\nRan 2 tests in 0.045s\nOK  But what about other numbers than integers? The next example adds floats to the mix.  # example5.py\n\n\ufefffrom nose.tools import raises\nfrom hypothesis import given, assume\nfrom hypothesis.strategies import integers, floats, one_of\n\ndef division(x, y):\n    return float(x) / float(y)\n\n@given(one_of(integers(), floats()))       #  -----------\ndef test_div(x):\n     Test integers and floats. \ufeff\n    assume(x   0)\n    print x\n    assert division(x*2, x) == 2.0\n\n@raises(ZeroDivisionError)\ndef test_divzero():\n     Test division by zero. \ufeff\ufeff\ufeff\n    division('4', 0)  Interestingly adding floats causes some trouble with really large values\nlike 8.98846567431158e+307 in this example.  $ nosetests example5.py\nF.\n======================================================================\nFAIL: example5.test_div\n----------------------------------------------------------------------\nTraceback (most recent call last):\n[...]\n    assert division(x*2, x) == 2.0\nAssertionError: \n--------------------   begin captured stdout   ---------------------\n[...]\n2.38756119474e+307\n8.9873684495e+307\n8.98846567431e+307\nFalsifying example: test_div(x=8.98846567431158e+307)\n8.98846567431e+307\n---------------------   end captured stdout   ----------------------\n----------------------------------------------------------------------\nRan 2 tests in 0.500s\nFAILED (failures=1)  The cause of the failure becomes obvious when one executes the mathematical\noperation in the Python shell.   8.98846567431158e+307*2/8.98846567431158e+307 == 2.0\nFalse  8.98846567431158e+307*2/8.98846567431158e+307\ninf  8.98846567431158e+307*2\ninf  Hypothesis is really good at finding such corner-cases. Although in this example\nit does not actually break the  division()  function, few people would have thought\nof this case without the help of Hypothesis. I certainly hadn't.  I hope this article provided a very brief introduction to Hypothesis and what value\nit adds to testing Python code. Check out the Hypothesis documentation as there\nare many more features.  I plan to add Hypothesis based testing to my Python projects\nsoon but I somehow fear the outcome ;-)", 
            "title": "Testing Python code with Hypothesis"
        }, 
        {
            "location": "/80211s_wireless_mesh/", 
            "text": "802.11s Wireless Mesh Network\n\n\nThis document is work in progress\n\n\nOverview\n\n\nOriginally the 802.11 WiFi standards defined two modes of operation, \n\"ad-hoc\" and \"infrastructure\".\nThe 802.11s amendment introduces another mode: mesh networks.\nThe distinguishing feature of mesh networks is that each node is able to forward\n802.11 frames to other nodes, potentially extending the range of the overall\nnetwork. This is different from \"infrastructure mode\" where all nodes communicate\nvia a central Access Point.\n\n\n\n\nNodes in a wireless mesh network may be mobile and it is the task of a (OSI layer 2)\nmesh routing protocols to continuously determine the optimal path between any two\nmesh nodes. The 802.11s document mandates the \n\nHybrid Wireless Mesh Protocol (HWMP)\n\nas the standard routing protocol but others can be implemented.\n\n\nIn this document I am going to describe how to configure a small wireless mesh network\nbased on the open80211s implementation on a few RaspberryPi.\n\n\nHardware \n Software\n\n\nThe following hardware and software was used for this experiment.\n\n\n\n\nMultiple RaspberryPi (various models) serving as Wireless Mesh Nodes and clients.\n\n\nelement14 WIPI WLAN USB Module\n\n  for Raspberry Pi as it supports mesh mode.\n\n\n\n\nConfiguring open80211s\n\n\nIn this section I am going to focus on how to get an 802.11s mesh network up and\nrunning using the \n\nopen80211s\n\nsoftware. open80211s is an open-source implementation\nof the recently ratified IEEE 802.11s wireless mesh standard. The project's Wiki\npage provides a lot of background information about 802.11s and the steps summarised\nin this document are based on the Wiki page.\n\n\nThe 2016-05-27-raspbian-jessie-lite.img version of Raspbian serves as the base for\nmy experiments with the open80211s software. It is good practice to update the\ndistribution first.\n\n\n$ sudo apt-get update\n$ sudo apt-get dist-upgrade\n$ reboot\n\n$ uname -a\nLinux yellow 4.4.13+ #894 Mon Jun 13 12:43:26 BST 2016 armv6l GNU/Linux\n\n\n\n\nKernel support\n\n\nThe WiPi USB WLAN adapter uses a RT5370 chip which is supported through the \n\nRT2800 driver\n. Most importantly is uses the\nmac80211 module which is a pre-requisite for open80211s to work.\n\n\n$ lsusb\nBus 001 Device 005: ID 148f:5370 Ralink Technology, Corp. RT5370 Wireless Adapter\n...\n\n$ sudo modprobe rt2800usb\n\n$ lsmod | grep 2800\nrt2800usb              18877  0\nrt2800lib              82155  1 rt2800usb\nrt2x00usb              12680  1 rt2800usb\nrt2x00lib              48998  3 rt2x00usb,rt2800lib,rt2800usb\nmac80211              608549  3 rt2x00lib,rt2x00usb,rt2800lib\ncrc_ccitt               1732  1 rt2800lib\n\n\n\n\nIn my setup, the WiPi adapter appears as the wlan1 interface.\n\n\n$ iwconfig\n...\nwlan1     IEEE 802.11bgn  ESSID:off/any\n          Mode:Managed  Access Point: Not-Associated   Tx-Power=20 dBm\n          Retry short limit:7   RTS thr:off   Fragment thr:off\n          Power Management:off\n\n\n\n\nCreating a wireless mesh network\n\n\nAs long as there is kernel support for the WLAN adapter, and the adapter supports\n'mesh' mode, creating a wireless mesh is fairly straightforward. It involves the\nfollowing steps.\n\n\n\n\nDefining a mesh interface name (mesh0 in the example below) and setting a \nmesh_idi\n.\n   The mesh identifier has a similar purpose to the SSID in a \"normal\" WLAN.\n\n\nSetting the channel. The WiPi adapter only supports the 2.4 GHz band and after doing\n   a site survey I decided to use channel 4.\n\n\nShutting down the wlanX interface and bringing up the mesh0 interface instead.\n\n\nAssigning an IP address.\n\n\n\n\n$ sudo iw dev wlan1 interface add mesh0 type mp mesh_id MYMESHID\n$ sudo iw dev mesh0 set channel 4\n$ sudo ifconfig wlan1 down\n$ sudo ifconfig mesh0 up\n$ sudo ip addr add 10.1.100.10/24 dev mesh0\n\n\n\n\nIn my lab, I created a wireless mesh network as shown below. Let's see whether all\nnodes are visible.\n\n\n\n\npi@yellow$ cat /etc/hosts\n127.0.0.1    localhost yellow\n10.2.1.51    blue-mesh\n10.2.1.52    white-mesh\n10.2.1.53    yellow-mesh\n10.2.1.54    red-mesh\n\npi@yellow$ fping white-mesh red-mesh yellow-mesh blue-mesh\nwhite-mesh is alive\nred-mesh is alive\nyellow-mesh is alive\nblue-mesh is alive\n\n\n\n\nThere are a few commands that display status information about the mesh. The \nstation\ndump\n command displays all neighbouring mesh nodes.\n\n\npi@yellow$ sudo iw dev mesh0 station dump | grep Station\nStation 40:a5:ef:0f:41:ef (on mesh0)\nStation 40:a5:ef:0f:4b:e3 (on mesh0)\n\n\n\n\nThe output of the \nmpath dump\n command shows the current HWMP routing table.\nNote how node 40:a5:ef:0f:46:df is reached via 40:a5:ef:0f:41:ef as it did not show\nas a neighbour node in station dump.\n\n\npi@yellow$ sudo iw dev mesh0 mpath dump\nDEST ADDR         NEXT HOP          IFACE    SN      METRIC  QLEN    EXPTIME         DTIM    DRET    FLAGS\n40:a5:ef:0f:4b:e3 40:a5:ef:0f:4b:e3 mesh0    2       8769    0       0       0       0       0x14\n40:a5:ef:0f:41:ef 40:a5:ef:0f:41:ef mesh0    5       8577    0       0       100     0       0x14\n40:a5:ef:0f:46:df 40:a5:ef:0f:41:ef mesh0    11      18786   0       0       200     1       0x4\n\n\n\n\nBecause bitrate most links have a fairly weak signal, the bitrate is slow. This is reflected in the approximately 500 Kbits/sec bandwidth reported by iperf.\n\n\npi@yellow$ sudo iw dev mesh0 station dump | grep bitrate\n     tx bitrate:     1.0 MBit/s\n     rx bitrate:     1.0 MBit/s\n     tx bitrate:     1.0 MBit/s\n     rx bitrate:     1.0 MBit/s\n\n\n\n\nSecurity\n\n\nNote Unfortunately this currently does not work with the rt2800 driver (https://github.com/cozybit/authsae/issues/34).\n\n\nCurrently the released version of wpa_supplicant does not support mesh mode. 802.11s\nrequires the \"Simultaneous Authentication of Equals (SAE)\" protocol with is implemented\nin the (https://github.com/cozybit/authsae) project. Unfortunately this package must\nbe installed manually and has a few dependencies.\n\n\n$ sudo apt-get install cmake libssl-dev libconfig-dev libnl-3-dev libnl-genl-3-dev\n$ git clone https://github.com/cozybit/authsae\n$ cd authsae\n$ make\n$ sudo make install\n$ ls /usr/local/etc/authsae.cfg /usr/local/bin/meshd* /usr/local/bin/mon\n/usr/local/bin/meshd\n/usr/local/bin/meshd-nl80211\n/usr/local/bin/mon\n/usr/local/etc/authsae.cfg\n\n\n\n\nThe README explains the different settings in /usr/local/etc/authsae.cfg. Once\nconfigured, start meshd-nl80211 as follows:\n\n\n$ sudo meshd-nl80211 -c /usr/local/etc/authsae.cfg -o /var/log/meshd.log -B\n\n\n\n\nRouting between wireless mesh and LAN\n\n\nA wireless mesh node that connects to a non-mesh network is called a Mesh Point\nPortal (MPP). Most documents describe how a Mesh Point Portal is used to bridge\nthe mesh and the non-mesh networks. I am going to describe this in the next section.\nFirst I explain how one can make the Mesh Point Portal a router connecting both\nnetworks.\n\n\n\n\nNodes yellow and white are both MPP with a VRRP address of 10.2.1.1 \"floating\"\n  between them on the mesh network.\n\n\nNodes yellow and white run a dynamic routing protocol on the non-mesh network\n  (RIPv2 in the example below) to learn routes from other routers.\n\n\nNodes red and blue use 10.2.1.1 as the default gateway.\n\n\n\n\n\n\nConfigure VRRP on nodes yellow and white\n\n\npi@yellow$ sudo apt-get install keepalived\n\npi@yellow$ sudo vi /etc/keepalived/keepalived.conf\nvrrp_instance VI_1 {\n    state MASTER\n    interface mesh0\n    virtual_router_id 100\n    priority 150\n    advert_int 1\n    authentication {\n        auth_type PASS\n        auth_pass mypasswd\n    }\n    virtual_ipaddress {\n        10.2.1.1\n    }\n}\n\n\n\n\nI decided to start keepalived from the command line. After a few seconds the mesh0 interface will have been assigned the 10.2.1.1 address.\n\n\npi@yellow$ sudo systemctl stop keepalived\n\npi@yellow$ sudo keepalived -f /etc/keepalived/keepalived.conf --vrrp\n\npi@yellow$ ip add li mesh0\n5: mesh0: \nBROADCAST,MULTICAST,UP,LOWER_UP\n mtu 1500 qdisc mq state UP group default qlen 1000\n    link/ether 40:a5:ef:0f:54:5a brd ff:ff:ff:ff:ff:ff\n    inet 10.2.1.53/24 scope global mesh0\n       valid_lft forever preferred_lft forever\n    inet 10.2.1.1/32 scope global mesh0\n       valid_lft forever preferred_lft forever\n\n\n\n\nThe same steps must be performed on node white, with the only difference that the\npriority setting in the configuration file must be different.\n\n\nConfigure dynamic routing on nodes yellow and white\n\n\nFor the purpose of simplicity I'll be configuring RIPv2 as this is the only protocol my\n(consumer grade) Internet Router supports.\n\n\n\n\nEnable IPv4 forwarding.\n\n\nCreate a minimal /etc/quagga/zebra.conf. Nothing will work without this file!\n\n\nConfigure RIPv2 in /etc/quagga/ripd.conf.\n\n\n\n\npi@yellow$ sudo sysctl net.ipv4.ip_forward=1    # enable forwarding\npi@yellow$ sudo apt-get install quagga\npi@yellow$ sudo vi /etc/quagga/daemons\nzebra=yes\n...\nripd=yes\n\npi@yellow$ sudo vi /etc/quagga/zebra.conf\nhostname yellow\n\npi@yellow$ sudo vi /etc/quagga/ripd.conf\nrouter rip\n  network eth0\n  redistribute connected\n\npi@yellow$ sudo systemctl start quagga\n\n\n\n\nConfigure the default gateway on red and blue\n\n\nThis step is straightforward, e.g.\n\n\npi@blue$ sudo route add -net default gw 10.2.1.1\npi@blue$ route -n\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.2.1.1        0.0.0.0         UG    0      0        0 mesh0\n10.2.1.0        0.0.0.0         255.255.255.0   U     0      0        0 mesh0\n\n\n\n\nNow I can ran a full traceroute to the Internet.\n\n\npi@blue$ sudo traceroute -I 150.101.213.146\ntraceroute to 150.101.213.146 (150.101.213.146), 30 hops max, 60 byte packets\n 1  yellow-mesh      3.668 ms   3.480 ms   3.465 ms\n 2  10.1.1.1         3.430 ms   3.367 ms   3.453 ms\n 3  150.101.32.128  14.801 ms  16.476 ms  17.640 ms\n 4  150.101.35.165  18.812 ms  24.582 ms  24.557 ms\n 5  150.101.40.134  24.444 ms  20.036 ms  19.048 ms\n 6  150.101.213.146 16.619 ms  14.815 ms  14.666 ms\n\n\n\n\nInitially the packets will be routed via yellow as it currently holds the VRRP\naddress for the default gateway. If node yellow becomes unavailable, the VRRP\naddress will move to node white.\n\n\nThe main disadvantage of a routed solution is that the mesh nodes will send all\nnon-local traffic to the Portal that is currently the default gateway.\nIt is not possible to load-balance between multiple portals. In large mesh\ntopologies this may be a major disadvantage.\n\n\nBridging the wireless mesh and the LAN\n\n\nThe alternative to routing between a mesh and a non-mesh network is bridging\nthem.\n\n\n\n\nCreate a bridge with the non-mesh and mesh interface.\n  Disable Spanning Tree on this bridge.\n\n\nConfigure the Mesh Gateways to send HWMP gate announcements.\n\n\n\n\n\n\n$ TODO\n\n\n\n\nLinks\n\n\n802.11s\n\n\nThe following links were useful sources of information.\n\n\n\n\n802.11s Mesh Networking\n\n\nIEEE 802.11s Tutorial\n\n\nOpenWRT 802.11s based wireless mesh network\n\n\n\n\nOther Wireless Mesh Protocols\n\n\nApart from 802.11s there are a couple of alternative protocols implementing wireless\nmesh networks.\n\n\n\n\nMobile Mesh Networks with the Raspberry Pi\n\n\nEnabling mesh (ad-hoc) network on multiple Raspberry Pi\u2019s\n\n\nHeterogeneous Wireless Mesh Network Technology Evaluation for Space Proximity and Surface Applications", 
            "title": "802.11s Wireless Mesh Network"
        }, 
        {
            "location": "/80211s_wireless_mesh/#80211s-wireless-mesh-network", 
            "text": "This document is work in progress", 
            "title": "802.11s Wireless Mesh Network"
        }, 
        {
            "location": "/80211s_wireless_mesh/#overview", 
            "text": "Originally the 802.11 WiFi standards defined two modes of operation, \n\"ad-hoc\" and \"infrastructure\".\nThe 802.11s amendment introduces another mode: mesh networks.\nThe distinguishing feature of mesh networks is that each node is able to forward\n802.11 frames to other nodes, potentially extending the range of the overall\nnetwork. This is different from \"infrastructure mode\" where all nodes communicate\nvia a central Access Point.   Nodes in a wireless mesh network may be mobile and it is the task of a (OSI layer 2)\nmesh routing protocols to continuously determine the optimal path between any two\nmesh nodes. The 802.11s document mandates the  Hybrid Wireless Mesh Protocol (HWMP) \nas the standard routing protocol but others can be implemented.  In this document I am going to describe how to configure a small wireless mesh network\nbased on the open80211s implementation on a few RaspberryPi.", 
            "title": "Overview"
        }, 
        {
            "location": "/80211s_wireless_mesh/#hardware-software", 
            "text": "The following hardware and software was used for this experiment.   Multiple RaspberryPi (various models) serving as Wireless Mesh Nodes and clients.  element14 WIPI WLAN USB Module \n  for Raspberry Pi as it supports mesh mode.", 
            "title": "Hardware &amp; Software"
        }, 
        {
            "location": "/80211s_wireless_mesh/#configuring-open80211s", 
            "text": "In this section I am going to focus on how to get an 802.11s mesh network up and\nrunning using the  open80211s \nsoftware. open80211s is an open-source implementation\nof the recently ratified IEEE 802.11s wireless mesh standard. The project's Wiki\npage provides a lot of background information about 802.11s and the steps summarised\nin this document are based on the Wiki page.  The 2016-05-27-raspbian-jessie-lite.img version of Raspbian serves as the base for\nmy experiments with the open80211s software. It is good practice to update the\ndistribution first.  $ sudo apt-get update\n$ sudo apt-get dist-upgrade\n$ reboot\n\n$ uname -a\nLinux yellow 4.4.13+ #894 Mon Jun 13 12:43:26 BST 2016 armv6l GNU/Linux", 
            "title": "Configuring open80211s"
        }, 
        {
            "location": "/80211s_wireless_mesh/#kernel-support", 
            "text": "The WiPi USB WLAN adapter uses a RT5370 chip which is supported through the  RT2800 driver . Most importantly is uses the\nmac80211 module which is a pre-requisite for open80211s to work.  $ lsusb\nBus 001 Device 005: ID 148f:5370 Ralink Technology, Corp. RT5370 Wireless Adapter\n...\n\n$ sudo modprobe rt2800usb\n\n$ lsmod | grep 2800\nrt2800usb              18877  0\nrt2800lib              82155  1 rt2800usb\nrt2x00usb              12680  1 rt2800usb\nrt2x00lib              48998  3 rt2x00usb,rt2800lib,rt2800usb\nmac80211              608549  3 rt2x00lib,rt2x00usb,rt2800lib\ncrc_ccitt               1732  1 rt2800lib  In my setup, the WiPi adapter appears as the wlan1 interface.  $ iwconfig\n...\nwlan1     IEEE 802.11bgn  ESSID:off/any\n          Mode:Managed  Access Point: Not-Associated   Tx-Power=20 dBm\n          Retry short limit:7   RTS thr:off   Fragment thr:off\n          Power Management:off", 
            "title": "Kernel support"
        }, 
        {
            "location": "/80211s_wireless_mesh/#creating-a-wireless-mesh-network", 
            "text": "As long as there is kernel support for the WLAN adapter, and the adapter supports\n'mesh' mode, creating a wireless mesh is fairly straightforward. It involves the\nfollowing steps.   Defining a mesh interface name (mesh0 in the example below) and setting a  mesh_idi .\n   The mesh identifier has a similar purpose to the SSID in a \"normal\" WLAN.  Setting the channel. The WiPi adapter only supports the 2.4 GHz band and after doing\n   a site survey I decided to use channel 4.  Shutting down the wlanX interface and bringing up the mesh0 interface instead.  Assigning an IP address.   $ sudo iw dev wlan1 interface add mesh0 type mp mesh_id MYMESHID\n$ sudo iw dev mesh0 set channel 4\n$ sudo ifconfig wlan1 down\n$ sudo ifconfig mesh0 up\n$ sudo ip addr add 10.1.100.10/24 dev mesh0  In my lab, I created a wireless mesh network as shown below. Let's see whether all\nnodes are visible.   pi@yellow$ cat /etc/hosts\n127.0.0.1    localhost yellow\n10.2.1.51    blue-mesh\n10.2.1.52    white-mesh\n10.2.1.53    yellow-mesh\n10.2.1.54    red-mesh\n\npi@yellow$ fping white-mesh red-mesh yellow-mesh blue-mesh\nwhite-mesh is alive\nred-mesh is alive\nyellow-mesh is alive\nblue-mesh is alive  There are a few commands that display status information about the mesh. The  station\ndump  command displays all neighbouring mesh nodes.  pi@yellow$ sudo iw dev mesh0 station dump | grep Station\nStation 40:a5:ef:0f:41:ef (on mesh0)\nStation 40:a5:ef:0f:4b:e3 (on mesh0)  The output of the  mpath dump  command shows the current HWMP routing table.\nNote how node 40:a5:ef:0f:46:df is reached via 40:a5:ef:0f:41:ef as it did not show\nas a neighbour node in station dump.  pi@yellow$ sudo iw dev mesh0 mpath dump\nDEST ADDR         NEXT HOP          IFACE    SN      METRIC  QLEN    EXPTIME         DTIM    DRET    FLAGS\n40:a5:ef:0f:4b:e3 40:a5:ef:0f:4b:e3 mesh0    2       8769    0       0       0       0       0x14\n40:a5:ef:0f:41:ef 40:a5:ef:0f:41:ef mesh0    5       8577    0       0       100     0       0x14\n40:a5:ef:0f:46:df 40:a5:ef:0f:41:ef mesh0    11      18786   0       0       200     1       0x4  Because bitrate most links have a fairly weak signal, the bitrate is slow. This is reflected in the approximately 500 Kbits/sec bandwidth reported by iperf.  pi@yellow$ sudo iw dev mesh0 station dump | grep bitrate\n     tx bitrate:     1.0 MBit/s\n     rx bitrate:     1.0 MBit/s\n     tx bitrate:     1.0 MBit/s\n     rx bitrate:     1.0 MBit/s", 
            "title": "Creating a wireless mesh network"
        }, 
        {
            "location": "/80211s_wireless_mesh/#security", 
            "text": "Note Unfortunately this currently does not work with the rt2800 driver (https://github.com/cozybit/authsae/issues/34).  Currently the released version of wpa_supplicant does not support mesh mode. 802.11s\nrequires the \"Simultaneous Authentication of Equals (SAE)\" protocol with is implemented\nin the (https://github.com/cozybit/authsae) project. Unfortunately this package must\nbe installed manually and has a few dependencies.  $ sudo apt-get install cmake libssl-dev libconfig-dev libnl-3-dev libnl-genl-3-dev\n$ git clone https://github.com/cozybit/authsae\n$ cd authsae\n$ make\n$ sudo make install\n$ ls /usr/local/etc/authsae.cfg /usr/local/bin/meshd* /usr/local/bin/mon\n/usr/local/bin/meshd\n/usr/local/bin/meshd-nl80211\n/usr/local/bin/mon\n/usr/local/etc/authsae.cfg  The README explains the different settings in /usr/local/etc/authsae.cfg. Once\nconfigured, start meshd-nl80211 as follows:  $ sudo meshd-nl80211 -c /usr/local/etc/authsae.cfg -o /var/log/meshd.log -B", 
            "title": "Security"
        }, 
        {
            "location": "/80211s_wireless_mesh/#routing-between-wireless-mesh-and-lan", 
            "text": "A wireless mesh node that connects to a non-mesh network is called a Mesh Point\nPortal (MPP). Most documents describe how a Mesh Point Portal is used to bridge\nthe mesh and the non-mesh networks. I am going to describe this in the next section.\nFirst I explain how one can make the Mesh Point Portal a router connecting both\nnetworks.   Nodes yellow and white are both MPP with a VRRP address of 10.2.1.1 \"floating\"\n  between them on the mesh network.  Nodes yellow and white run a dynamic routing protocol on the non-mesh network\n  (RIPv2 in the example below) to learn routes from other routers.  Nodes red and blue use 10.2.1.1 as the default gateway.", 
            "title": "Routing between wireless mesh and LAN"
        }, 
        {
            "location": "/80211s_wireless_mesh/#configure-vrrp-on-nodes-yellow-and-white", 
            "text": "pi@yellow$ sudo apt-get install keepalived\n\npi@yellow$ sudo vi /etc/keepalived/keepalived.conf\nvrrp_instance VI_1 {\n    state MASTER\n    interface mesh0\n    virtual_router_id 100\n    priority 150\n    advert_int 1\n    authentication {\n        auth_type PASS\n        auth_pass mypasswd\n    }\n    virtual_ipaddress {\n        10.2.1.1\n    }\n}  I decided to start keepalived from the command line. After a few seconds the mesh0 interface will have been assigned the 10.2.1.1 address.  pi@yellow$ sudo systemctl stop keepalived\n\npi@yellow$ sudo keepalived -f /etc/keepalived/keepalived.conf --vrrp\n\npi@yellow$ ip add li mesh0\n5: mesh0:  BROADCAST,MULTICAST,UP,LOWER_UP  mtu 1500 qdisc mq state UP group default qlen 1000\n    link/ether 40:a5:ef:0f:54:5a brd ff:ff:ff:ff:ff:ff\n    inet 10.2.1.53/24 scope global mesh0\n       valid_lft forever preferred_lft forever\n    inet 10.2.1.1/32 scope global mesh0\n       valid_lft forever preferred_lft forever  The same steps must be performed on node white, with the only difference that the\npriority setting in the configuration file must be different.", 
            "title": "Configure VRRP on nodes yellow and white"
        }, 
        {
            "location": "/80211s_wireless_mesh/#configure-dynamic-routing-on-nodes-yellow-and-white", 
            "text": "For the purpose of simplicity I'll be configuring RIPv2 as this is the only protocol my\n(consumer grade) Internet Router supports.   Enable IPv4 forwarding.  Create a minimal /etc/quagga/zebra.conf. Nothing will work without this file!  Configure RIPv2 in /etc/quagga/ripd.conf.   pi@yellow$ sudo sysctl net.ipv4.ip_forward=1    # enable forwarding\npi@yellow$ sudo apt-get install quagga\npi@yellow$ sudo vi /etc/quagga/daemons\nzebra=yes\n...\nripd=yes\n\npi@yellow$ sudo vi /etc/quagga/zebra.conf\nhostname yellow\n\npi@yellow$ sudo vi /etc/quagga/ripd.conf\nrouter rip\n  network eth0\n  redistribute connected\n\npi@yellow$ sudo systemctl start quagga", 
            "title": "Configure dynamic routing on nodes yellow and white"
        }, 
        {
            "location": "/80211s_wireless_mesh/#configure-the-default-gateway-on-red-and-blue", 
            "text": "This step is straightforward, e.g.  pi@blue$ sudo route add -net default gw 10.2.1.1\npi@blue$ route -n\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\n0.0.0.0         10.2.1.1        0.0.0.0         UG    0      0        0 mesh0\n10.2.1.0        0.0.0.0         255.255.255.0   U     0      0        0 mesh0  Now I can ran a full traceroute to the Internet.  pi@blue$ sudo traceroute -I 150.101.213.146\ntraceroute to 150.101.213.146 (150.101.213.146), 30 hops max, 60 byte packets\n 1  yellow-mesh      3.668 ms   3.480 ms   3.465 ms\n 2  10.1.1.1         3.430 ms   3.367 ms   3.453 ms\n 3  150.101.32.128  14.801 ms  16.476 ms  17.640 ms\n 4  150.101.35.165  18.812 ms  24.582 ms  24.557 ms\n 5  150.101.40.134  24.444 ms  20.036 ms  19.048 ms\n 6  150.101.213.146 16.619 ms  14.815 ms  14.666 ms  Initially the packets will be routed via yellow as it currently holds the VRRP\naddress for the default gateway. If node yellow becomes unavailable, the VRRP\naddress will move to node white.  The main disadvantage of a routed solution is that the mesh nodes will send all\nnon-local traffic to the Portal that is currently the default gateway.\nIt is not possible to load-balance between multiple portals. In large mesh\ntopologies this may be a major disadvantage.", 
            "title": "Configure the default gateway on red and blue"
        }, 
        {
            "location": "/80211s_wireless_mesh/#bridging-the-wireless-mesh-and-the-lan", 
            "text": "The alternative to routing between a mesh and a non-mesh network is bridging\nthem.   Create a bridge with the non-mesh and mesh interface.\n  Disable Spanning Tree on this bridge.  Configure the Mesh Gateways to send HWMP gate announcements.    $ TODO", 
            "title": "Bridging the wireless mesh and the LAN"
        }, 
        {
            "location": "/80211s_wireless_mesh/#links", 
            "text": "", 
            "title": "Links"
        }, 
        {
            "location": "/80211s_wireless_mesh/#80211s", 
            "text": "The following links were useful sources of information.   802.11s Mesh Networking  IEEE 802.11s Tutorial  OpenWRT 802.11s based wireless mesh network", 
            "title": "802.11s"
        }, 
        {
            "location": "/80211s_wireless_mesh/#other-wireless-mesh-protocols", 
            "text": "Apart from 802.11s there are a couple of alternative protocols implementing wireless\nmesh networks.   Mobile Mesh Networks with the Raspberry Pi  Enabling mesh (ad-hoc) network on multiple Raspberry Pi\u2019s  Heterogeneous Wireless Mesh Network Technology Evaluation for Space Proximity and Surface Applications", 
            "title": "Other Wireless Mesh Protocols"
        }
    ]
}